[{"content":" # å…³äºè®¾è®¡ç»å¯¹å€¼absçš„ä¸€äº›æ€è€ƒ ã€Œå–ç»å¯¹å€¼ã€å¯¹äº Integer æ¯«æ— ç–‘é—®ç›´æ¥åˆ¤æ–­æ­£è´Ÿ\nMath::abs(int) 1 2 3 public static int abs(int a) { return (a \u0026lt; 0) ? -a : a; } æ³¨æ„åˆ°åŒç²¾åº¦æµ®ç‚¹æ•° Double å®˜æ–¹ä½¿ç”¨ä»¥ä¸‹å®ç°\nMath::abs(double) 1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0D) ? 0.0D - a : a; } Java éµå¾ª IEEE-754 æ ‡å‡†ï¼Œå› æ­¤å®ç°ä¸Šå­˜åœ¨ +0.0 \u0026amp; -0.0ï¼Œä¸¤è€…é™¤äº†æ–‡æœ¬è¡¨ç¤ºä¸åŒï¼Œåœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¹Ÿä¸åŒã€‚å¦‚ï¼š1 / +- 0.0 å¾—åˆ°çš„ç»“æœæ˜¯ +Infinity \u0026amp; -Infinity\nabs è®¡ç®—ç»“æœä»ç„¶æ˜¯è´Ÿæ•°ï¼Œå‡ºç°é”™è¯¯ï¼ŒåŸå› æ—¢æ˜¯ +0.0 == -0.0\n1 2 3 4 5 6 7 8 9 10 11 public class Solution { public static void main(String[] args) { double x = -0.0; if (1 / abs(x) \u0026lt; 0) { System.out.println(\u0026#34;abs(x) \u0026lt; 0\u0026#34;); } } public static double abs(double a) { return (a \u0026lt; 0) ? -a : a; } } å°è¯•è§£å†³é—®é¢˜ï¼Œæ·»åŠ åˆ¤æ–­æ¡ä»¶ï¼šif (val \u0026lt; 0 || val == -0.0) å¯¹ -0.0 å•ç‹¬è€ƒè™‘ï¼Œè¿›è¡ŒåŒé‡åˆ¤æ–­ï¼Œè¿™é‡Œé‡‡ç”¨ Double::compare(double, double) å®ç°\næˆåŠŸå®ç°\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt; 0 || Double.compare(value, -0.0) == 0) { return -value; } return value; } å†è¿½æ±‚æè‡´çš„ä¼˜åŒ–ã€‚æŸ¥çœ‹ Double::compare å®ç°ã€‚\nå¯¹äºæ­£æ•°è¿›è¡Œé¢å¤–çš„ä¸¤æ¬¡æ¯”è¾ƒ, å¯¹äº -0.0 è¿›è¡Œé¢å¤–çš„ ä¸‰æ¬¡ æ¯”è¾ƒ, å¯¹äº +0.0 è¿›è¡Œé¢å¤–çš„ å››æ¬¡ æ¯”è¾ƒ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static int compare(double d1, double d2) { if (d1 \u0026lt; d2) return -1; // Neither val is NaN, thisVal is smaller if (d1 \u0026gt; d2) return 1; // Neither val is NaN, thisVal is larger // Cannot use doubleToRawLongBits because of possibility of NaNs. long thisBits = Double.doubleToLongBits(d1); long anotherBits = Double.doubleToLongBits(d2); return (thisBits == anotherBits ? 0 : // Values are equal (thisBits \u0026lt; anotherBits ? -1 : // (-0.0, 0.0) or (!NaN, NaN) 1)); // (0.0, -0.0) or (NaN, !NaN) } è€Œå®é™…ä¸Šï¼Œè¦æƒ³å®ç°åªéœ€è¦ Double::doubleToLongBits æ–¹æ³•ï¼Œå°† Double è½¬ Long\n1 2 3 4 5 6 7 8 9 10 private static final long MINUS_ZERO_LONG_BITS = Double.doubleToLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } ä¸è¿‡ Double::doubleToLongBits ä¹Ÿåªæœ‰å¾®ä¸è¶³é“çš„æ€§èƒ½æå‡ï¼Œå› ä¸ºå®ƒä¼šå¯¹ NaN è¿›è¡Œçº¦æŸï¼ŒNaN ä¼šèµ‹å€¼ä¸º 0x7ff8000000000000L ï¼Œå¦‚æœç¡®ä¿ abs å…¥å‚è‚¯å®šæ˜¯ doubleï¼Œåˆ™åªéœ€è¦å–å‡º Double::doubleToRawLongBits\n1 2 3 4 5 6 public static long doubleToLongBits(double value) { if (!isNaN(value)) { return doubleToRawLongBits(value); } return 0x7ff8000000000000L; } äºæ˜¯å°±å˜æˆè¿™æ ·å®ç°\n1 2 3 4 5 6 7 8 9 private static final long MINUS_ZERO_LONG_BITS =Â Double.doubleToRawLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToRawLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } åˆ° JDK8 å°±ç»“æŸäº†ï¼Œè€Œ JDK9 å¼€å§‹å¼•å…¥ @HotSpotIntrinsicCandidate æ³¨è§£ï¼Œå³ HotSpot JVM å†…éƒ¨çš„ JIT compiler ä¼šç§»é™¤ JDK ä¸­çš„å®ç°æ–¹æ³•ï¼Œé‡‡ç”¨ CPU æŒ‡ä»¤ç›´æ¥å®ç°ï¼Œè¿™ä¼šæ¯”é«˜çº§è¯­è¨€è½¬æ±‡ç¼–è½¬æœºå™¨è¯­è¨€è¦å¿«å¾ˆå¤šï¼Œæ¯•ç«Ÿ CPU å¹¶ä¸ä¼šåœ¨ä¹æ•°æ®ç±»å‹çš„é—®é¢˜ï¼Œåªéœ€è¦é‡æ–°è§£é‡Š(reinterpreting) å‚¨å­˜åœ¨ CPU å¯„å­˜å™¨çš„ä¸€ç»„ä½çš„é—®é¢˜ï¼Œä»¥ä¾¿äºä¸ Java æ•°æ®ç±»å‹ä¸€è‡´ã€‚\n1 2 @HotSpotIntrinsicCandidate public static native long doubleToRawLongBits(double value); ä½†è¿™ä¹ˆå®ç°ï¼Œä»ç„¶æœ‰æ¡ä»¶åˆ†æ”¯ï¼Œå¦‚æœ CPU åˆ†æ”¯é¢„æµ‹(branch predictor) å¤±è¯¯ï¼Œæ€§èƒ½å¼€é”€å°±ä¼šå¢å¤§ã€‚æ¥ä¸‹æ¥è€ƒè™‘å‡å°‘æ¡ä»¶åˆ†æ”¯ã€‚\nåˆ©ç”¨ 0.0 ä¸ +/0.0 ä½œå·®ï¼Œéƒ½ä¼šä½¿æ­£è´Ÿé›¶è½¬åŒ–ä¸ºæ­£é›¶\n1 2 System.out.println(0.0 - (-0.0)); // 0.0 System.out.println(0.0 - (+0.0)); // 0.0 å¯¹æ–¹æ³•è¿›è¡Œæ”¹å†™\n1 2 3 4 5 6 7 8 9 public static double abs(double value) { if (value == 0) { return 0.0 - value; } if (value \u0026lt; 0) { return -value; } return value; } æ³¨æ„åˆ°å¯¹äºæ™®é€šè´Ÿæ•°è€Œè¨€ï¼Œ0.0 - value ä¸ -value çš„ç»“æœç›¸åŒï¼Œæ‰€ä»¥åˆå¹¶åˆ†æ”¯\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt;= 0) { return 0.0 - value; } return value; } AKA\n1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0) ? 0.0 - a : a; } ä¼šå‘ç°ï¼ŒJDK Math::abs(double,double) å®ç°ç›¸åŒï¼ˆé€ƒ\néµå¾ª IEEE-754 çš„åŒç²¾åº¦æµ®ç‚¹æ•°äºŒè¿›åˆ¶è¡¨è¾¾å½¢å¼ï¼Œåªéœ€è¦å°†äºŒè¿›åˆ¶åœ¨é«˜ä½ç¬¦å·ä½æ”¹æˆ 0 å³å¯å®ç°è½¬æ­£æ•°(abs)ï¼Œéœ€è¦æ©ç  0x7fffffffffffffffL == 63ä½ 1 bit\n1 System.out.println(Long.bitCount(0x7fffffffffffffffL)); // 63 # æœ€ç»ˆå®ç° 1 2 3 4 public static double abs(double value) { return Double.longBitsToDouble( Double.doubleToRawLongBits(value) \u0026amp; 0x7fffffffffffffffL); } ğŸ“Œæ­¤ç‰ˆæœ¬ä¸å­˜åœ¨åˆ†æ”¯ï¼Œåœ¨æŸäº›æ¡ä»¶ä¸‹çš„ååé‡å¢åŠ  10%ï¼Œå•åˆ†æ”¯å®ç°åœ¨ Java æ ‡å‡†åº“å­˜åœ¨å¤šå¹´ï¼Œåœ¨éšå³åˆ°æ¥çš„ JDK 18 ä¸­ï¼Œæ”¹è¿›ç‰ˆæœ¬å·²ç»æäº¤ã€ŒFrom: 2021/9/18ã€\nç„¶è€Œåœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œè¿™äº›æ”¹è¿›å¹¶æ²¡æœ‰å¤ªå¤§æ„ä¹‰ï¼Œå› ä¸º JIT ç¼–è¯‘å™¨ä¼šé€‚å½“ä½¿ç”¨æ±‡ç¼–æŒ‡ä»¤(if available) ä¼šå®Œå…¨æ›¿ä»£ Java codeï¼Œæ‰€ä»¥è¿™ç§æ”¹åŠ¨å¹¶ ä¸èƒ½ ä½¿ç¨‹åºæ˜¾è‘—æ€§æå‡å¾ˆå¤šï¼ˆé€ƒ\n# ğŸ”—Reference One does not simply calculate the absolute value\nOpenJDK Double::compare\nJavaSE 8 doubleToLongBits\n","date":"2021-09-18T17:34:24+08:00","image":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/java-programming-cover_hu4193375dbb5d85283668ea46b44f9b7a_34987_120x120_fill_box_smart1_3.png","permalink":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/","title":"å…³äºè®¾è®¡ç»å¯¹å€¼ abs() çš„ä¸€äº›æ€è€ƒ"}]