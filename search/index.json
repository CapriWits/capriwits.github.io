[{"content":" Spring i18n 抽象封装实践 Spring 国际化基本使用 抽象国际化功能 定义接口 简单 i18n 消息 复杂 i18n 消息 i18n 工具类 使用 总结 Spring i18n 抽象封装实践 Spring 国际化基本使用 首先 maven 引入 spring-web 的依赖 在 resources 目录下，创建一个放国际化文本的文件夹，例如 /resources/i18n/，然后修改 resources/application.yml 配置文件 1 2 3 4 5 spring: messages: basename: i18n/messages encoding: UTF-8 useCodeAsDefaultMessage: true basename 指定翻译文本的前缀，可以带相对路径，即 i18n 文件夹。 messages 是文本前缀，文本名示例：messages.properties（默认文本，messages_en.properties（英文，messages_zh.properties（简体中文\n文本文件格式 有两种，一种直接 k-v 结构翻译，key = value，翻译时传 key，直接返回 value 的字符串；\n另一种用占位符大括号 {0} {1} {2}…\nmessages_en_US.properties： 1 greeting=Hello, {0}! messages_zh_CN.properties： 1 greeting=你好，{0}！ 使用 MessageSource 获取 i18n 文本 前端传 url 参数 lang，指定语言 当用户访问 /greet?name=John\u0026amp;lang=zh_CN 时，返回的消息将是 你好，John！；当用户访问 /greet?name=John\u0026amp;lang=en_US 时，返回的消息将是 Hello, John!。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import java.util.Locale; @RestController public class GreetingController { private final GreetingService greetingService; public GreetingController(GreetingService greetingService) { this.greetingService = greetingService; } @GetMapping(\u0026#34;/greet\u0026#34;) public String greet(@RequestParam String name, @RequestParam String lang) { Locale locale = new Locale(lang.split(\u0026#34;_\u0026#34;)[0], lang.split(\u0026#34;_\u0026#34;)[1]); return greetingService.getGreeting(name, locale); } } 当然，为了前端方便也可以统一用 HTTP Header，然后后端获取创建 java.util.Locale 对象\n1 @RequestHeader(value = \u0026#34;Accept-Language\u0026#34;, defaultValue = \u0026#34;zh-CN\u0026#34;) String lang 后端使用 org.springframework.context.MessageSource#getMessage(java.lang.String, java.lang.Object[], java.util.Locale) 翻译即可 参数分别为：文本 key；渲染参数数组（按顺序，地区对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.MessageSource; import org.springframework.stereotype.Service; import java.util.Locale; @Service public class GreetingService { @Autowired private MessageSource messageSource; public String getGreeting(String name, Locale locale) { return messageSource.getMessage(\u0026#34;greeting\u0026#34;, new Object[]{name}, locale); } } 抽象国际化功能 以上做法是直接替换掉国际化的内容，如果内容不多，且没有一些嵌套的文本，可以直接替换。\n嵌套文本指的是，key1 对应 value 里面，其中一个占位符的内容也是动态生成，拼接而成的。假如 {1} 也是一个国际化文本，对应另一个 key2 的内容，这中嵌套就需要先翻译 {1}，再渲染 value。\n可以写一个工具类，抽象 i18n 渲染功能。\n定义接口 I18nKey 只有一个方法，获取 key，实现类是一个枚举 I18nMessage 是一条 i18n 信息，除了获取 key，还有获取渲染值列表；类型上界限定为 I18nKey 实现类；getValues() 由于渲染的值对象不止 String，还可能是还是一个 I18nMessage，需要递归地渲染，所以获取列表泛型只限制 Object 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * I18n 配置文件 key */ @FunctionalInterface public interface I18nKey { String getKey(); } /** * I18n 基本信息, 包括配置文件 key 和对应模板顺序的待渲染值 * * @param \u0026lt;K\u0026gt; I18n 配置文件 key 类型 * @see I18nKey */ public interface I18nMessage\u0026lt;K extends I18nKey\u0026gt; { /** * 获取 I18n 配置文件 key * * @return I18n 配置文件 key */ K getKey(); /** * 获取 I18n 配置文件 key 对应模板顺序的待渲染值 * * @return I18n 配置文件 key 对应模板顺序的待渲染值 */ List\u0026lt;Object\u0026gt; getValues(); } 简单 i18n 消息 简单 i18n key，对应简单 i18n message，即简单 k-v 结构，无渲染参数 实现 I18nKey 接口，是一个枚举类 下面是审批示例，设计三类，审批添加、操作和撤销的 i18n key 成员变量只有 String key，需要实现接口方法 getKey 为了实现 key 还原枚举对象，实现 fromKey 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 简单 i18n 配置文件 key 枚举, 直接获取 i18n 字符串, 无渲染 * * @see I18nKey * @see SimpleI18nMessage */ @AllArgsConstructor @Slf4j public enum SimpleI18nKey implements I18nKey { /** * 审批添加操作日志 */ APPROVAL_ADD_TYPENAME(\u0026#34;opLog.approvalAdd.typeName\u0026#34;), APPROVAL_ADD_FIELDS_DESCRIPTION(\u0026#34;opLog.approvalAdd.fields.description\u0026#34;), /** * 操作审核操作日志 */ APPROVAL_REVIEW_TYPENAME(\u0026#34;opLog.approvalReview.typeName\u0026#34;), APPROVAL_REVIEW_FIELDS_UNSOLVED(\u0026#34;opLog.approvalReview.fields.unsolved\u0026#34;), APPROVAL_REVIEW_FIELDS_APPROVED(\u0026#34;opLog.approvalReview.fields.approved\u0026#34;), APPROVAL_REVIEW_FIELDS_REJECTED(\u0026#34;opLog.approvalReview.fields.rejected\u0026#34;), /** * 撤销审批操作日志 */ APPROVAL_WITHDRAW_TYPENAME(\u0026#34;opLog.approvalWithdraw.typeName\u0026#34;), APPROVAL_WITHDRAW_FIELDS_AUTOWITHDRAW(\u0026#34;opLog.approvalWithdraw.fields.autoWithdraw\u0026#34;), ; public final String key; @Override public String getKey() { return key; } /** * 根据给定的字符串查找对应的枚举对象, 主要应用在操作日志从数据库取出后还原 Key 枚举对象 * * @param key i18n 配置文件 key 字符串 * @return 匹配的枚举对象，如果没有找到则返回 {@code null} */ public static SimpleI18nKey fromKey(String key) { for (SimpleI18nKey i18nKey : SimpleI18nKey.values()) { if (i18nKey.getKey().equals(key)) { return i18nKey; } } log.error(\u0026#34;I18n key not found: [{}]\u0026#34;, key); return null; } } 简单 i18n 消息体 成员变量是泛型中同类型的 SimpleI18nKey 枚举对象 实现 I18nMessage 接口方法 获取 key，直接返回成员变量 获取渲染参数列表，简单 kv 消息，无渲染参数，返回 null 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * 简单 i18n 消息体, 无需渲染(无 args), 根据 key 直接获取 i18n 内容 * * @see SimpleI18nKey */ @AllArgsConstructor public class SimpleI18nMessage implements I18nMessage\u0026lt;SimpleI18nKey\u0026gt; { public final SimpleI18nKey key; @Override public SimpleI18nKey getKey() { return key; } /** * 无需渲染(无 args) * * @return {@code null} */ @Override public List\u0026lt;Object\u0026gt; getValues() { return null; } } 复杂 i18n 消息 复杂 i18n 消息，即带有渲染的 i18n 消息，渲染值可能带有 i18n message 需要递归渲染\n以添加操作审批日志为例， I18nKey 实现类同样是一个枚举，只有 String key 一个成员变量；\nI18nMessage 实现类，泛型 ApprovalAddAdditionOtherI18nKey 限制 i18n key 类型，待渲染信息有两个，放在成员变量位置，同 key，由有参构造方法统一设置；可以看到 description 变量对应第二个参数 {1} 同样是一个 I18nMessage，该 i18n message 泛型限制为简单 i18n key；获取渲染参数 getValues() 时，按顺序传入 approvalId 和 description\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * 添加审批操作日志 i18n 配置文件 key * * @see ApprovalAddAdditionOtherI18nMsg */ @AllArgsConstructor public enum ApprovalAddAdditionOtherI18nKey implements I18nKey { ADDITION_OTHER(\u0026#34;opLog.approvalAdd.addition.other\u0026#34;); public final String key; @Override public String getKey() { return key; } } @AllArgsConstructor public class ApprovalAddAdditionOtherI18nMsg implements I18nMessage\u0026lt;ApprovalAddAdditionOtherI18nKey\u0026gt; { // 发起未知类型审批；审批ID = {0}；{1} public final ApprovalAddAdditionOtherI18nKey key; public final Integer approvalId; public final I18nMessage\u0026lt;SimpleI18nKey\u0026gt; description; @Override public ApprovalAddAdditionOtherI18nKey getKey() { return key; } @Override public List\u0026lt;Object\u0026gt; getValues() { return Arrays.asList(approvalId, description); } } i18n 工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 /** * I18n 工具类 \u0026lt;p\u0026gt; * 提供两种方式渲染国际化信息 * \u0026lt;ol\u0026gt; * \u0026lt;li\u0026gt;根据 key 直接渲染国际化消息\u0026lt;/li\u0026gt; {@link #processI18nMessage(String, Locale, Object...)} * \u0026lt;li\u0026gt;根据 {@link I18nMessage} 实现类渲染国际化消息\u0026lt;/li\u0026gt; {@link #processI18nMessage(I18nMessage, Locale)} * \u0026lt;/ol\u0026gt; * * @see I18nMessage * @see I18nKey * @see SimpleI18nMessage */ @Slf4j @Component(\u0026#34;i18n-utils\u0026#34;) public class I18nUtils { private final MessageSource messageSource; @Autowired public I18nUtils(MessageSource messageSource) { this.messageSource = messageSource; } /** * 直接根据 key 获取国际化消息 * * @param key i18n 配置文件 key * @param locale {@link Locale} 语言环境 * @param args 按模板顺序的参数列表, 可为 {@code null} * @return 渲染后国际化消息 */ public String processI18nMessage(String key, Locale locale, Object... args) { // 为避免渲染模版出现多余分隔符, 如 Integer 增加千位逗号分隔符, 统一 String 进行渲染 String[] argsArray = Arrays.stream(args).map(String::valueOf).toArray(String[]::new); return getMessage(key, locale, argsArray); } /** * 直接根据 key 获取国际化消息, 渲染失败时返回默认消息 * * @param key i18n 配置文件 key * @param defaultMessage 默认消息, 可为 {@code null} * @param locale {@link Locale} 语言环境 * @param args 按模板顺序的参数列表, 可为 {@code null} * @return 渲染后国际化消息 */ public String processI18nMessage(String key, @Nullable String defaultMessage, Locale locale, Object... args) { // 为避免渲染模版出现多余分隔符, 如 Integer 增加千位逗号分隔符, 统一 String 进行渲染 String[] argsArray = Arrays.stream(args).map(String::valueOf).toArray(String[]::new); return getMessage(key, locale, defaultMessage, argsArray); } /** * 根据 {@link I18nMessage} 实现类和 {@link Locale} 语言环境获取渲染后的国际化消息 * * @param i18nMessage {@link I18nMessage} 实现类, 国际化消息 * @param locale {@link Locale} 语言环境 * @return 渲染后的国际化消息 */ public String processI18nMessage(@NonNull I18nMessage\u0026lt;?\u0026gt; i18nMessage, @NonNull Locale locale) { return resolveMessage(i18nMessage, locale); } /** * 处理国际化消息 * * @param i18nMessage {@link I18nMessage} 实现类, 国际化消息 * @param locale {@link Locale} 语言环境 * @return 渲染后的国际化消息 */ private String resolveMessage(@NonNull I18nMessage\u0026lt;?\u0026gt; i18nMessage, @NonNull Locale locale) { // 直接渲染简单国际化消息 if (i18nMessage instanceof SimpleI18nMessage) { return getMessage(i18nMessage.getKey().getKey(), locale, null); } String[] args = i18nMessage.getValues().stream() .map(value -\u0026gt; value instanceof I18nMessage ? resolveMessage((I18nMessage\u0026lt;?\u0026gt;) value, locale) : value) .map(String::valueOf) .toArray(String[]::new); return getMessage(i18nMessage.getKey().getKey(), locale, args); } /** * 获取国际化消息 * * @param key i18n 配置文件 key * @param locale {@link Locale} 语言环境 * @param args 按模板顺序的参数列表, 可为 {@code null} * @return 渲染后国际化消息; 若未找到消息, 返回空字符串 */ private String getMessage(String key, Locale locale, String[] args) { String i18nMessage = \u0026#34;\u0026#34;; try { i18nMessage = messageSource.getMessage(key, args, locale); } catch (NoSuchMessageException e) { log.error(\u0026#34;Resolve i18n message [{}] error\u0026#34;, key, e); } return i18nMessage; } /** * 获取国际化消息 * * @param key i18n 配置文件 key * @param locale {@link Locale} 语言环境 * @param defaultMessage 渲染失败, 默认消息 * @param args 按模板顺序的参数列表, 可为 {@code null} * @return 渲染后国际化消息; 若未找到消息, 返回默认消息 */ private String getMessage(String key, Locale locale, String defaultMessage, String[] args) { return messageSource.getMessage(key, args, defaultMessage, locale); } } 渲染的主要类是通过 org.springframework.context.MessageSource 渲染的参数 args 虽然是 Object 数组，不限制类型，但是传入 Integer 时，渲染千位以上的值时，会自动带上千分位分隔符，类似 1,000 ，因此渲染千统一将 args 转为 String ，保持原数值格式 org.springframework.context.MessageSource#getMessage(java.lang.String, java.lang.Object[], java.util.Locale) 找不到 i18n key，默认会抛出 NoSuchMessageException 异常，而不是返回 null，需要注意 org.springframework.context.MessageSource#getMessage(java.lang.String, java.lang.Object[], java.lang.String, java.util.Locale) 提供 defaultMessage 参数，找不到 i18n key 不抛异常，返回默认字符串 processI18nMessage(String key, Locale locale, Object... args) 参数同 getMessage，直接根据字符串 key 获取 i18n 消息，不建议使用，因为实际使用有大量魔法值，即 i18n key 是魔法值字符串，统一用枚举管理便于复用，注释和查看引用。 processI18nMessage(@NonNull I18nMessage\u0026lt;?\u0026gt; i18nMessage, @NonNull Locale locale) 渲染 i18n 信息方法，只需要 i18n message 对象和地区对象 Locale ；I18nMessage 会带有 key 信息，因此只需要一个对象即可 resolveMessage(@NonNull I18nMessage\u0026lt;?\u0026gt; i18nMessage, @NonNull Locale locale) 处理 i18n message 的核心方法，先判断 i18n message 是否为简单 i18n 消息 SimpleI18nMessage，如果是，直接 getMessage；如果不是，需要将参数 args 依次获取，判断 instanceof I18nMessage ，是 i18n message 递归处理消息即可，直到所有国际化消息都被渲染 使用 1 2 3 4 5 6 7 public String getShowAddition(Locale lang) { I18nUtils i18n = BeanContext.getBean(I18nUtils.class); SimpleI18nMessage descMsg = new SimpleI18nMessage(SimpleI18nKey.APPROVAL_ADD_FIELDS_DESCRIPTION); return i18n.processI18nMessage(new ApprovalAddAdditionOtherI18nMsg( ApprovalAddAdditionOtherI18nKey.ADDITION_OTHER, approvalId, descMsg) , lang); } getShowAddition 传入 Locale 地区对象 先用 org.springframework.beans.factory.BeanFactory#getBean(java.lang.Class\u0026lt;T\u0026gt;) 获取 i18n 工具类 创建简单 i18n 消息，指定其 i18n 枚举 key 创建复杂 i18n 消息，先指定复杂 i18n key，然后按渲染顺序传入成员变量，其中 description 是上面创建的简单 i18n 消息 总结 以上递归渲染的抽象工具类，在复杂的递归渲染场景可以比较方便地使用，语义和可读性都较高。\n如只有简单的 i18n 消息渲染场景，直接使用 MessageSource 渲染即可，无需过度封装；注意管理好 i18n key 的魔法值。\n","date":"2024-09-11T15:03:29+08:00","image":"https://capriwits.com/post/spring-i18n-abstract-encapsulation-practice/spring-cover_hu11476348701166988821.png","permalink":"https://capriwits.com/post/spring-i18n-abstract-encapsulation-practice/","title":"Spring i18n 抽象封装实践"},{"content":" MongoDB 修改表分片规则 背景 原理 解决方案 RenameCollection 影子拷贝 mongodump 和 mongorestore mongoexport 和 mongoimport MongoDB 修改表分片规则 背景 Golang 模块需要 upsert MongoDB 的一个 Collection，该表的分片键 Sharding key 规则是指定 pid 和 did 双主键， 业务上需要改为 did 单主键，直接使用 golang mongo-driver 的 FindOneAndUpdate 操作会报错\nshadow fail to Update Mongodb (ShardKeyNotFound) Query for sharded findAndModify must contain the shard key\n原因是分片键的规则与查询的 filter 对不上（did 单主键\n为了适配业务，需要将该表的分片规则进行修改，改为 did 单主键\n测试环境：MongoDB 3.6 版本，分片两份 shard-0 和 shard-1\n以下方案需要停机操作，无法做到读写操作同时修改（需要将原表删除\n原理 参照 MySQL 影子拷贝法\n将待修改表 base 表 copy 一份影子 base_tmp，该影子的分片键规则进行修改，再将 base 表改为 base_bak 用于冗余保留备份，也可 dump 成文件，然后 base_tmp 改为 base 表\n解决方案 RenameCollection 影子拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 use admin; // Step 1: 创建影子拷贝并设置新分片键 db.runCommand({ shardCollection: \u0026#34;db_name.base\u0026#34;, key: {did: 1} }); use db_name; // Step 2: 复制数据 db.base.find().forEach(function (doc) { db.base_tmp.insertOne(doc); }); // Step 3: 重命名原始集合以保留备份 db.base.renameCollection(\u0026#34;base_bak\u0026#34;); // Step 4: 重命名临时集合为原始集合 db.base_tmp.renameCollection(\u0026#34;base\u0026#34;); 实际操作会在 renameCollection 这一步报错\nYou can't rename a sharded collection\n不能修改一个分片的表，因此解决方案只能将数据 dump 出来，再 restore 回新分片的表里\nmongodump 和 mongorestore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // mongodump 备份数据 mongodump --host ip:port --username ROOT --password PASSWORD --authenticationDatabase admin --db DB_NAME --collection base --out=base.bak.d // 删除 base 表 db.base.drop() // 创建分片需要 root 账户，admin 表中 use admin; // 创建影子拷贝并设置新分片键 db.runCommand({ shardCollection: \u0026#34;db_name.base\u0026#34;, key: {did: 1} }); sh.status() // 检查新分片规则 mongorestore --host ip:port --username ROOT --password PASSWORD --authenticationDatabase admin --db DB_NAME --collection base --dir=ota_shadow_device_base.bak.d/DB_NAME/base.bson Failed: ota_car_online.ota_shadow_device_base: error creating indexes for ota_car_online.ota_shadow_device_base: createIndex error: { mongodb-mongodb-sharding-shard-0/mongodb-mongodb-sharding-shard0-data-0.mongodb-mongodb-sharding-headless.bota-basic.svc.cluster.local:27017, mongodb-mongodb-sharding-shard0-data-1.mongodb-mongodb-sharding-headless.bota-basic.svc.cluster.local:27017, mongodb-mongodb-sharding-shard0-data-2.mongodb-mongodb-sharding-headless.bota-basic.svc.cluster.local:27017: \u0026quot;request doesn't allow collection to be created implicitly\u0026quot;, mongodb-mongodb-sharding-shard-1/mongodb-mongodb-sharding-shard1-data-0.mongodb-mongodb-sharding-headless.bota-basic.svc.cluster.local:27017, mongodb-mongodb-sharding-shard1-data-1.mongodb-mongodb-sharding-headless.bota-basic.svc.cluster.local:27017, mongodb-mongodb-sharding-shard1-data-2.mongodb-mongodb-sharding-headless.bota-basic.svc.cluster.local:27017: \u0026quot;cannot create unique index over { pid: 1.0, did: 1.0 } with shard key pattern { did: 1.0 }\u0026quot; }\n使用 mongodump 指定 collection 只导出该 collection 的 bson 信息，但是还会带有额外的原始集合元数据，包括分片信息，因此旧数据的分片规则并不适用新分片集合中，所以 mongorestore 会报错\nmongoexport 和 mongoimport mongoexport 和 mongoimport 的组合，一般涉及到单表，且纯数据操作，不涉及与 MongoDB 属性绑定的场景，例如导出导入 json csv 数据，因此使用该方案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 修改 ota_shadow_device_base 分片规则 # 1. 在 /mongodb/bin 目录下，将 ota_shadow_device_base 数据备份 mongoexport --host IP:PORT --username $ROOT --password $PASSWORD --authenticationDatabase admin --db $DB_NAME --collection ota_shadow_device_base --out ota_shadow_device_base.json --readPreference primary # 2. 删除原集合(务必先执行上述备份 mongo --host IP:PORT --username $ROOT --password $PASSWORD --authenticationDatabase admin --eval \u0026#34;db.ota_shadow_device_base.drop();\u0026#34; ota_car_online # 3. 使用 ROOT 账户进入 mongo-cli # 手动创建集合，建立索引 use ota_car_online; db.createCollection(\u0026#39;ota_shadow_device_base\u0026#39;); db.ota_shadow_device_base.createIndex({did: 1}, {unique: true}); db.ota_shadow_device_base.createIndex({pid: 1}); # 手动创建集合分片规则（需 ROOT 账户才能创建 use admin; db.runCommand({shardCollection: \u0026#39;ota_car_online.ota_shadow_device_base\u0026#39;, key: {did: 1}}); # 以下命令检查分片规则是否生效 # ota_car_online.ota_shadow_device_base, shard key: { \u0026#34;did\u0026#34; : 1 } sh.status(); # 4. 数据还原 # 退出 mongo-cli，在备份文件根目录处恢复数据，按照新分片规则导入数据 mongoimport --host IP:PORT --username $ROOT --password $PASSWORD --authenticationDatabase admin --db $DB_NAME --collection ota_shadow_device_base --file ota_shadow_device_base.json --writeConcern majority sh.status() 查看分片是否设置成功\n","date":"2024-07-12T22:58:46+08:00","image":"https://capriwits.com/post/mongodb-modifying-table-sharding-rules/mongodb-cover_hu17737138940704033801.jpg","permalink":"https://capriwits.com/post/mongodb-modifying-table-sharding-rules/","title":"MongoDB 修改表分片规则"},{"content":" HTTPS 单双向认证及证书相关 一些常识 CA 证书和私钥 服务端和客户端SSL证书 证书格式 证书请求 证书链 HTTPS 单向认证（SSL/TLS) HTTPS 双向认证（mTLS） 自签名证书 mTLS 实战 自签名根证书 CA 自签名服务端证书 自签名客户端证书 验证 带证书的成功调用 不带证书的调用 Reference HTTPS 单双向认证及证书相关 一些常识 CA 证书和私钥 CA（Certificate Authority）证书：由权威认证机构（CA）签发的数字证书，用于证明证书持有者的身份。CA证书可以自签名，也可以由更上级的CA签名。根CA证书通常是自签名的，用 root.key 签名一个 root.crt 根证书。CA 证书可能是一个根证书（root.crt），也可能是一个中间证书（子 CA 证书）。 CA 私钥：用于签发和验证其他证书。CA私钥非常重要，必须妥善保管，确保不会泄露。 公钥是存储在证书里的，key 是私钥，用于签发证书 常见 CA 机构，可以签发服务端 SSL 证书\nLet\u0026rsquo;s Encrypt：Let\u0026rsquo;s Encrypt 是一个免费的、自动化的证书颁发机构，致力于推动全球网站加密化。 DigiCert：DigiCert 是一家知名的商业证书颁发机构，提供各种 SSL/TLS 证书和数字证书解决方案。 Sectigo（原名Comodo）：Sectigo 是一家全球领先的数字证书颁发机构，提供 SSL 证书、代码签名证书等安全解决方案。 GlobalSign：GlobalSign 是一家全球性的数字证书颁发机构，提供 SSL 证书、代码签名证书、身份验证等服务。 GoDaddy：GoDaddy 是一家知名的域名注册商，也提供 SSL 证书和其他网络安全服务。 Entrust Datacard：Entrust Datacard 是一家提供数字证书、身份验证和加密解决方案的领先供应商。 服务端和客户端SSL证书 服务端SSL证书：安装在服务器上的数字证书，用于加密客户端和服务器之间的通信，确保数据的安全性和完整性。通常由 CA 签发，包含服务器的公钥信息。（server.crt 客户端SSL证书：安装在客户端上的数字证书，用于验证客户端的身份，通常在双向认证（mTLS）中使用。(client.crt 证书格式 X.509 X.509 格式证书是一种标准的公钥证书格式，X.509 证书的主要特点和组成部分包括：\n标准化格式：X.509 定义了一个结构化的证书格式，确保了不同系统之间能够互操作和理解。 公钥信息：证书包含了证书持有者的公钥，这是用于加密数据或验证数字签名的关键部分。 身份信息：证书还包括证书持有者的身份信息，如组织名称、组织单元、国家/地区等。这些信息帮助验证证书持有者的身份。 签名：证书由证书颁发机构（CA）进行数字签名，以确保其完整性和真实性。这意味着如果证书被篡改，签名将不再有效。 有效期：每个 X.509 证书都有一个有效的时间范围，由“开始日期”和“结束日期”定义。这确保了证书的时效性和定期更新需求。 证书链和信任：X.509 证书通常是证书链的一部分，其中每个证书都由上一级证书颁发机构签名，最终追溯到一个受信任的根证书。这种结构建立了信任链，使得终端用户可以验证证书的合法性。 扩展性：X.509 证书支持扩展字段，允许添加额外信息，如密钥用途、证书策略等，以满足不同应用场景的需求 .crt 后缀证书，可能是 PEM 编码，也可能是 DER 编码\nPEM (Privacy Enhanced Mail) PEM 是一种广泛使用的编码格式，特别是安全领域的数据，如证书、密钥等。PEM 格式使用 Base64 编码的 ASCII 文本表示，并带有 \u0026quot;-----BEGIN CERTIFICATE-----\u0026quot; 和 \u0026quot;-----END CERTIFICATE-----\u0026quot; 的边界标记。可以以 ASCII 的格式存储 X.509 格式的证书 crt。\n证书可以存储公钥、私钥、证书、证书链、证书请求\n公钥：通常以 “-----BEGIN PUBLIC KEY-----” 和 “-----END PUBLIC KEY-----” 为边界\n私钥：通常以 “-----BEGIN PRIVATE KEY-----” 和 “-----END PRIVATE KEY-----” 为边界，或者对于某些类型的私钥（如RSA私钥），可能是 “-----BEGIN RSA PRIVATE KEY-----” 和 “-----END RSA PRIVATE KEY-----”\n证书：包括服务器证书、中间证书等，通常以 “-----BEGIN CERTIFICATE-----” 和 “-----END CERTIFICATE-----” 为边界\n证书请求（如CSR，Certificate Signing Request）：通常以 “-----BEGIN CERTIFICATE REQUEST-----” 和 “-----END CERTIFICATE REQUEST-----” 为边界。\n1 2 3 4 # 查看 PEM 证书信息 openssl x509 -in certificate.pem -text -noout # PEM 转 DER openssl x509 -in cert.crt -outform der -out cert.der DER (Distinguished Encoding Rules) X.509 证书在二进制形式下通常使用 DER 格式。虽然 DER 本身不是证书格式，但它是 X.509 证书 二进制编码 的基础。存证书，没有私钥\n1 2 3 4 # 查看 DER 证书信息 openssl x509 -in certificate.der -inform der -text -noout # DER 转 PEM openssl x509 -in cert.crt -inform der -outform pem -out cert.pem PFX/PKCS12（Public-Key Cryptography Standards #12） 常用于存储私钥和相关的公钥证书链，以 .pfx 或 .p12 为文件扩展名。这种格式可以转换为 PEM 格式，从而提取出私钥和证书。通常包含私钥、证书和证书链的组合\nPKCS12 可以包含 公钥、私钥、证书和证书链 ，并且有 密码保护 ，一般便于不同平台传输，常用于客户端证书（client.crt → client.p12\n1 2 3 4 # 查看 p12 证书信息 openssl pkcs12 -info -in your_certificate.p12 # p12 转 pem openssl pkcs12 -in your_certificate.p12 -nocerts -out private_key.pem JKS（Java KeyStore） JKS 是 Java 中用于存储密钥和证书的专有格式，二进制格式。JKS 文件通常以 .jks 为文件扩展名。在 Java 应用程序中管理密钥和证书，包括私钥、证书、证书链等信息。JKS 文件通常需要密码来保护存储在其中的密钥和证书。\n生成和转换需要用到 Java keytool\n证书请求 CSR（Certificate Signing Request）是一种包含有关组织或个人信息的加密文本，用于向证书颁发机构（CA）申请数字证书。CSR包含了将包含在数字证书中的 公钥，以及与该公钥相关联的组织信息，如组织名称、域名等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 先创建一个私钥 key openssl genrsa -out root.key 4096 # 再根据 key 生成一个证书请求 openssl req -new -out root.csr -key root.key # 下面是提示出来需要填写到 csr 的信息，包括国家、省、城市、公司、单位、域名、密码等信息 Country Name (2 letter code) [XX]:cn State or Province Name (full name) []:bj Locality Name (eg, city) [Default City]:bj Organization Name (eg, company) [Default Company Ltd]:alibaba Organizational Unit Name (eg, section) []:test Common Name (eg, your name or your servers hostname) []:root Email Address []:a.alibaba.com A challenge password []: An optional company name []: # 用 key 和 csr 生成 10 年期限的根证书 root.crt openssl x509 -req -in root.csr -out root.crt -signkey root.key -CAcreateserial -days 3650 生成的 root.csr 证书请求，一方面包含公司信息，另一方面包含 key 对应的公钥。\n用 key 和 csr 就可以签发一个证书 root.crt。假设公司信息不改变，key 也未泄露，由于公私钥是对应的，理论上等到 root.crt 过期后，可以再次签发一个 root.crt，达到续签的目的。\n证书链 证书链是指从根证书（Root Certificate）开始，通过中间证书（Intermediate Certificate）逐级签发，直到最终的终端用户证书（End-Entity Certificate）\n根证书（Root Certificate）：自签名的证书，位于证书链的最顶端。根证书由权威认证机构（CA）发行并保存在受信任的存储区中。 中间证书（Intermediate Certificate）：由根证书或其他中间证书签发，形成证书链。中间证书用于签发更下级的证书。 终端用户证书（End-Entity Certificate）：由根证书或中间证书签发，最终用于服务器或客户端。 root.crt → intermediate1.crt → intermediate2.crt → server.crt\n以上过程 root.crt 是根证书，以 root.crt 为 CA 签发中间证书 intermediate1.crt，再用 intermediate1.crt 为 CA 签发 intermediate2.crt 中间证书，最后 intermediate2.crt 签发终端用户证书 server.crt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 openssl genrsa -out root.key 4096 # 根私钥 # 根证书 openssl req -new -x509 -days 3650 -key root.key -out root.crt -subj \u0026#34;/CN=Root CA\u0026#34; openssl genrsa -out intermediate1.key 4096 # 中间证书 1 私钥 # 中间证书请求 1 openssl req -new -key intermediate1.key -out intermediate1.csr -subj \u0026#34;/CN=Intermediate CA 1\u0026#34; # 根证书签发中间证书 1 openssl x509 -req -in intermediate1.csr -CA root.crt -CAkey root.key -CAcreateserial -out intermediate1.crt -days 3650 openssl genrsa -out intermediate2.key 4096 # 中间证书 2 私钥 # 中间证书请求 2 openssl req -new -key intermediate2.key -out intermediate2.csr -subj \u0026#34;/CN=Intermediate CA 2\u0026#34; # 中间证书 1 做 CA 签发中间证书 2 openssl x509 -req -in intermediate2.csr -CA intermediate1.crt -CAkey intermediate1.key -CAcreateserial -out intermediate2.crt -days 3650 openssl genrsa -out server.key 4096 # 终端用户证书私钥 # 终端用户证书请求 openssl req -new -key server.key -out server.csr -subj \u0026#34;/CN=server.example.com\u0026#34; # 中间证书 2 做 CA 签发终端用户证书 openssl x509 -req -in server.csr -CA intermediate2.crt -CAkey intermediate2.key -CAcreateserial -out server.crt -days 365 根证书（root.crt）：通常保存在操作系统或浏览器的受信任证书存储中。作为信任链的根，客户端无需直接访问它。\n中间证书一（intermediate1.crt）和中间证书二（intermediate2.crt）：保存在服务器上，用于建立完整的证书链。客户端会通过服务器传递的证书链验证服务器证书的可信度。\n终端用户证书（server.crt）和私钥（server.key）：安装在服务器上，用于加密通信和验证服务器身份。\n完整的证书链文件：服务器需要提供一个包含所有中间证书的文件，以便客户端可以验证证书链。可以将中间证书和终端证书合并成一个文件。\n一般来说，证书链的顺序是：SSL 证书 → 中间证书 → 根证书，依次向上游，一般客户端会默认信任根证书，可以省略\n1 cat server.crt intermediate2.crt intermediate1.crt \u0026gt; fullchain.crt 服务器配置示例（以Nginx为例）：\n1 2 3 4 5 6 7 server { listen 443 ssl; server_name example.com; ssl_certificate /path/to/fullchain.crt; ssl_certificate_key /path/to/server.key; } 客户端验证证书链：\n客户端验证终端用户证书是否由中间证书二签发。 客户端验证中间证书二是否由中间证书一签发。 客户端验证中间证书一是否由根证书签发。 客户端检查根证书是否在受信任的根证书列表中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 验证中间证书一是否由根证书签发 openssl verify -CAfile root.crt intermediate1.crt # intermediate1.crt: OK # 接下来，验证中间证书二是否由中间证书一签发。 # 为了验证中间证书二，先创建一个证书链文件，包含根证书和中间证书一。 cat root.crt intermediate1.crt \u0026gt; chain1.pem openssl verify -CAfile chain1.pem intermediate2.crt # intermediate2.crt: OK # 最后，验证终端用户证书是否由中间证书二签发。 # 创建一个证书链文件，包含根证书和所有中间证书。 cat root.crt intermediate1.crt intermediate2.crt \u0026gt; chain2.pem openssl verify -CAfile chain2.pem server.crt # server.crt: OK # 为了完整验证整个证书链，你可以使用以下命令验证整个证书链文件 fullchain.crt： cat server.crt intermediate2.crt intermediate1.crt \u0026gt; fullchain.crt openssl verify -CAfile root.crt fullchain.crt # fullchain.crt: OK HTTPS 单向认证（SSL/TLS) 客户端发起建立HTTPS连接请求，将SSL协议版本的信息发送给服务器端； 服务器端将本机的公钥证书（server.crt）发送给客户端； 客户端读取公钥证书（server.crt），取出了服务端公钥； 客户端生成一个随机数（密钥 R），用刚才得到的服务器公钥去加密这个随机数形成密文，发送给服务端； 服务端用自己的私钥（server.key）去解密这个密文，得到了密钥 R 服务端和客户端在后续通讯过程中就使用这个密钥 R 进行通信了。 服务端部署时，将 server.crt 和 server.key 上传至服务器即可。如果服务端用云服务 LoadBalancer，则将两个文件上传至 LB 绑定的地方，例如阿里云 CLB 界面有证书管理，AWS 有 ACM（AWS Certificate Manager）专门管理证书等；如果服务端用 K8S Ingress 配置 SSL，则将两个文件 base64 到 secret，再将 secret 配置到 ingress 实现 SSL 单向认证。如果用 Nginx，Apache 等服务器，则找到对应的方式上传证书即可。\nkey 私钥用于解密客户端公钥加密的数据，也可以在服务端生成签名。crt 证书配合客户端已经信任的 CA，验证服务端的身份（crt 带有服务端的信息，包括国家、城市、公司、域名、证书起始和过期时间等；\n一般公网环境，客户端默认在本机都会安装操作系统时，默认信任一些 CA，例如微软系统 IIS 专门管理证书，浏览器自动读取，用户无感；\nHTTPS 双向认证（mTLS） 客户端发起建立 HTTPS 连接请求，将 SSL 协议版本的信息发送给服务端； 服务器端将本机的公钥证书（server.crt）发送给客户端； 客户端读取公钥证书（server.crt），取出了服务端公钥； 客户端将客户端公钥证书（client.crt）发送给服务器端； 服务器端使用根证书（root.crt）解密客户端公钥证书，拿到客户端公钥； 客户端发送自己支持的加密方案给服务器端； 服务器端根据自己和客户端的能力，选择一个双方都能接受的加密方案，使用客户端的公钥加密后发送给客户端； 客户端使用自己的私钥解密加密方案，生成一个随机数 R，使用服务器公钥加密后传给服务器端； 服务端用自己的私钥去解密这个密文，得到了密钥 R 服务端和客户端在后续通讯过程中就使用这个密钥 R 进行通信了。 证书准备：\n服务器端公钥证书：server.crt 服务器端私钥文件：server.key 根证书：root.crt 客户端公钥证书：client.crt 客户端私钥文件：client.key 客户端集成证书（包括公钥和私钥，用于浏览器访问场景）：client.p12 所有证书都可以找 CA 机构签发，如果内网使用，非公众，则可以自建 PKI（Public Key Infrastructure） 系统自签发。\n服务器除了单向认证步骤里，上传 server.crt 和 server.key 两个文件外，还需要额外添加 CA 证书 root.crt（假设 CA 证书就是根证书，不是子 CA 证书，否则需要上传整个证书链），这个 client-CA（root.crt) 证书相当于服务端也是一个客户端，需要提前信任一个签发 client.crt 的 CA 证书，便于客户端发送带客户端公钥的 client.crt 时，验明客户端身份，实现双向认证（即额外增加客户端的身份验证）。\n因此客户端本地除了已经信任签发 server.crt 的 CA 证书，也需要上传 client.crt 和 client.key，就像服务端一样，为了可以安装浏览器，还需要将 client.crt 转为 client.p12 便于安装。\n自签名证书 mTLS 实战 找一台机器有 openssl 的 linux 机器模拟自签名\n自签名根证书 CA （1）创建根证书私钥：\n1 openssl genrsa -out root.key 1024 （2）创建根证书请求文件：\n1 openssl req -new -out root.csr -key root.key 后续参数请自行填写，下面是一个例子：\n注意：CA 证书 Common Name 需要保证唯一性，不要与服务端证书或者客户端证书的 Common Name 相同。\n1 2 3 4 5 6 7 8 9 Country Name (2 letter code) [XX]:cn State or Province Name (full name) []:bj Locality Name (eg, city) [Default City]:bj Organization Name (eg, company) [Default Company Ltd]:alibaba Organizational Unit Name (eg, section) []:test Common Name (eg, your name or your servers hostname) []:root Email Address []:a.alibaba.com A challenge password []: An optional company name []: （3）创建根证书：\n1 openssl x509 -req -in root.csr -out root.crt -signkey root.key -CAcreateserial -days 3650 在创建证书请求文件的时候需要注意三点，下面生成服务器请求文件和客户端请求文件均要注意这三点： 根证书的 Common Name 填写 root 就可以，所有客户端和服务器端的证书这个字段需要填写域名，一定要注意的是，根证书的这个字段和客户端证书、服务器端证书不能一样； 其他所有字段的填写，根证书、服务器端证书、客户端证书需保持一致最后的密码可以直接回车跳过。\n经过上面三个命令行，我们最终可以得到一个签名有效期为 10 年的根证书 root.crt，后面我们可以用这个根证书去颁发服务器证书和客户端证书。\n自签名服务端证书 （1）生成服务器端证书私钥：\n1 openssl genrsa -out server.key 1024 （2） 生成服务器证书请求文件，过程和注意事项参考根证书，本节不详述：\n1 openssl req -new -out server.csr -key server.key （3） 生成服务器端公钥证书\n1 openssl x509 -req -in server.csr -out server.crt -signkey server.key -CA root.crt -CAkey root.key -CAcreateserial -days 3650 经过上面的三个命令，我们得到：\nserver.key：服务器端的密钥文件 server.crt：有效期十年的服务器端公钥证书，使用根证书和服务器端私钥文件一起生成\n自签名客户端证书 （1）生成客户端证书密钥：\n1 2 openssl genrsa -out client.key 1024 openssl genrsa -out client2.key 1024 （2） 生成客户端证书请求文件，过程和注意事项参考根证书，本节不详述：\n1 2 openssl req -new -out client.csr -key client.key openssl req -new -out client2.csr -key client2.key （3） 生客户端证书\n1 2 openssl x509 -req -in client.csr -out client.crt -signkey client.key -CA root.crt -CAkey root.key -CAcreateserial -days 3650 openssl x509 -req -in client2.csr -out client2.crt -signkey client2.key -CA root.crt -CAkey root.key -CAcreateserial -days 3650 （4） 生客户端p12格式证书，需要输入一个密码，选一个好记的，比如123456\n1 2 openssl pkcs12 -export -clcerts -in client.crt -inkey client.key -out client.p12 openssl pkcs12 -export -clcerts -in client2.crt -inkey client2.key -out client2.p12 重复使用上面的命令，我们得到两套客户端证书：\nclient.key / client2.key：客户端的私钥文件 client.crt / client2.key：有效期十年的客户端证书 使用根证书和客户端私钥一起生成 client.p12/client2.p12，这个证书文件包含客户端的公钥和私钥，主要用来给浏览器访问使用\n验证 使用 curl 加上证书路径，可以直接测试 Nginx 的 HTTPS 双向认证是否配置成功。下面我们测试三个用例：\n使用 client.crt / client.key 这一套客户端证书来调用服务器端 使用 client2.crt / client2.key 这一套客户端证书来调用服务器端 不使用证书来调用服务器端 带证书的成功调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #--cert指定客户端公钥证书的路径 #--key指定客户端私钥文件的路径 #-k 使用本参数不校验证书的合法性，因为我们用的是自签名证书 #可以使用-v来观察具体的SSL握手过程 curl --cert ./client.crt --key ./client.key https://integration-fred2.fredhuang.com -k -v * Rebuilt URL to: https://47.93.XX.XX/ * Trying 47.93.XX.XX... * TCP_NODELAY set * Connected to 47.93.XX.XX (47.93.XX.XX) port 443 (#0) * ALPN, offering h2 * ALPN, offering http/1.1 * Cipher selection: ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH * successfully set certificate verify locations: * CAfile: /etc/ssl/cert.pem CApath: none * TLSv1.2 (OUT), TLS handshake, Client hello (1): * TLSv1.2 (IN), TLS handshake, Server hello (2): * TLSv1.2 (IN), TLS handshake, Certificate (11): * TLSv1.2 (IN), TLS handshake, Server key exchange (12): * TLSv1.2 (IN), TLS handshake, Request CERT (13): * TLSv1.2 (IN), TLS handshake, Server finished (14): * TLSv1.2 (OUT), TLS handshake, Certificate (11): * TLSv1.2 (OUT), TLS handshake, Client key exchange (16): * TLSv1.2 (OUT), TLS handshake, CERT verify (15): * TLSv1.2 (OUT), TLS change cipher, Client hello (1): * TLSv1.2 (OUT), TLS handshake, Finished (20): * TLSv1.2 (IN), TLS change cipher, Client hello (1): * TLSv1.2 (IN), TLS handshake, Finished (20): * SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384 * ALPN, server accepted to use http/1.1 * Server certificate: * subject: C=CN; ST=BJ; L=BJ; O=Alibaba; OU=Test; CN=integration-fred2.fredhuang.com; emailAddress=a@alibaba.com * start date: Nov 2 01:01:34 2019 GMT * expire date: Oct 30 01:01:34 2029 GMT * issuer: C=CN; ST=BJ; L=BJ; O=Alibaba; OU=Test; CN=root; emailAddress=a@alibaba.com * SSL certificate verify result: unable to get local issuer certificate (20), continuing anyway. \u0026gt; GET / HTTP/1.1 \u0026gt; host:integration-fred2.fredhuang.com \u0026gt; User-Agent: curl/7.54.0 \u0026gt; Accept: */* \u0026gt; \u0026lt; HTTP/1.1 200 OK \u0026lt; Server: nginx/1.17.5 \u0026lt; Date: Sat, 02 Nov 2019 02:39:43 GMT \u0026lt; Content-Type: text/html \u0026lt; Content-Length: 612 \u0026lt; Last-Modified: Wed, 30 Oct 2019 11:29:45 GMT \u0026lt; Connection: keep-alive \u0026lt; ETag: \u0026#34;5db97429-264\u0026#34; \u0026lt; Accept-Ranges: bytes \u0026lt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; * Connection #0 to host 47.93.XX.XX left intact 使用 client2.crt / client2.key 这一套客户端证书来调用服务器端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 curl --cert ./client2.crt --key ./client2.key https://integration-fred2.fredhuang.com -k \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 不带证书的调用 1 2 3 4 5 6 7 8 9 curl https://integration-fred2.fredhuang.com -k \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;400 No required SSL certificate was sent\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;400 Bad Request\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;center\u0026gt;No required SSL certificate was sent\u0026lt;/center\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;center\u0026gt;nginx/1.17.5\u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 三个用例都符合预期，从第一个测试日志中可以看到，整个通信过程较长，客户端验证服务器端的证书，客户端也将自己的证书上传到服务器端进行验证。使用根证书颁发的两个客户端证书都可以正常发起双向HTTPS认证的调用。没有带客户端证书的调用会被服务器端拒绝服务。\nReference 什么是HTTPS双向认证(Mutual TLS authentication)_API 网关(API Gateway)-阿里云帮助中心\n使用CLB部署HTTPS业务（双向认证）_负载均衡(SLB)-阿里云帮助中心\n","date":"2024-06-09T16:47:46+08:00","image":"https://capriwits.com/post/https-tls-and-mtls-and-certificate-related/mtls-cover_hu7423576249796298622.png","permalink":"https://capriwits.com/post/https-tls-and-mtls-and-certificate-related/","title":"HTTPS 单双向认证及证书相关"},{"content":" Java 左值和右值的思考 前言 问题复现 字节码分析 其他实验 Summary 🔗Reference Java 左值和右值的思考 前言 刷算法题，用到小根堆「PriorityQueue」， 其中一个操作让我困惑了很久\n小根堆存储的是原数组为负值的下标，则小根堆堆顶为最小负数的下标\n本意是循环中，让最小负数取到相反数 k 次，变成一个正数\nwhile (k-- \u0026gt; 0) nums[queue.peek()] = -nums[queue.poll()];\n这一操作让我疑惑了很久，根据赋值表达式的性质，应该是从右计算到左，但是如果按照这个逻辑，就会让 poll() 先进行，后面才 peek() ， 这样下标的计算就出错了, 即 peek() 实际取的下标值已经被 poll() 出堆了\n问题复现 1 2 3 4 5 6 public static void main(String[] args) { int[] nums = {2, 1, 0}; PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(List.of(0, 1, 2)); nums[pq.peek()] = -nums[pq.poll()]; System.out.println(Arrays.toString(nums)); // [-2, 1, 0] } 小根存存储原数组下标，此时堆顶为 0\nnums[pq.peek()] = -nums[pq.poll()] 实际执行运行时状态是先执行 peek()，再执行 poll()，即从左到右，与赋值运算符 = 右值赋值给左值不同\n即 nums[0] = -nums[0] 取反\n字节码分析 使用 javap -c Solution.class 反编译字节码分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 32: invokestatic #15 // InterfaceMethod java/util/List.of:(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/List; 35: invokespecial #21 // Method java/util/PriorityQueue.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:(Ljava/util/Collection;)V 38: astore_2 39: aload_1 40: aload_2 41: invokevirtual #24 // Method java/util/PriorityQueue.peek:()Ljava/lang/Object; 44: checkcast #10 // class java/lang/Integer 47: invokevirtual #28 // Method java/lang/Integer.intValue:()I 50: aload_1 51: aload_2 52: invokevirtual #32 // Method java/util/PriorityQueue.poll:()Ljava/lang/Object; 55: checkcast #10 // class java/lang/Integer 58: invokevirtual #28 // Method java/lang/Integer.intValue:()I 先是堆的初始化，然后先执行 peek() 再执行 poll(), 即从左到右的顺序编译\n其他实验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main(String[] args) { int[] nums = {4, 5, 6}; nums[getIndex()] = -nums[getValue()]; // Should call getIndex first, then getValue System.out.println(Arrays.toString(nums)); // [4, -6, 6] } public static int getIndex() { System.out.println(\u0026#34;getIndex called\u0026#34;); return 1; } public static int getValue() { System.out.println(\u0026#34;getValue called\u0026#34;); return 2; } getIndex called\ngetValue called\n[4, -6, 6]\n1 2 3 18: invokestatic #7 // Method getIndex:()I 21: aload_1 22: invokestatic #13 // Method getValue:()I 同样，编译顺序也是从左至右\nSummary 不能按照赋值表达式 = 从右向左运行的思想思考 nums[queue.peek()] = -nums[queue.poll()]; 最终的赋值的确会按照右向左执行「赋值操作」，完成 置相反数 的操作 但是从最终字节码的执行顺序来看，对于 表达式 的计算，会 从左向右 计算，将前序准备工作「取值」完成后，才进行写操作，赋值。 🔗Reference 1005. K 次取反后最大化的数组和\n","date":"2024-06-02T18:57:02+08:00","image":"https://capriwits.com/post/thoughts-on-java-lvalues-and-rvalues/java-programming-cover_hu940919409602284940.png","permalink":"https://capriwits.com/post/thoughts-on-java-lvalues-and-rvalues/","title":"Java 左值和右值的思考"},{"content":" 关于设计绝对值abs的一些思考 最终实现 🔗Reference 关于设计绝对值abs的一些思考 「取绝对值」对于 Integer 毫无疑问直接判断正负\nMath::abs(int) 1 2 3 public static int abs(int a) { return (a \u0026lt; 0) ? -a : a; } 注意到双精度浮点数 Double 官方使用以下实现\nMath::abs(double) 1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0D) ? 0.0D - a : a; } Java 遵循 IEEE-754 标准，因此实现上存在 +0.0 \u0026amp; -0.0 ，两者除了文本表示不同，在计算过程中也不同。如：1 / +- 0.0 得到的结果是 +Infinity \u0026amp; -Infinity\nabs 计算结果仍然是负数，出现错误，原因既是 +0.0 == -0.0\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Solution { public static void main(String[] args) { double x = -0.0; if (1 / abs(x) \u0026lt; 0) { System.out.println(\u0026#34;abs(x) \u0026lt; 0\u0026#34;); } } public static double abs(double a) { return (a \u0026lt; 0) ? -a : a; } } 尝试解决问题，添加判断条件：if (val \u0026lt; 0 || val == -0.0) 对 -0.0 单独考虑，进行双重判断，这里采用 Double::compare(double, double) 实现\n成功实现\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt; 0 || Double.compare(value, -0.0) == 0) { return -value; } return value; } 再追求极致的优化。查看 Double::compare 实现。\n对于正数进行额外的两次比较, 对于 -0.0 进行额外的 三次 比较, 对于 +0.0 进行额外的 四次 比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static int compare(double d1, double d2) { if (d1 \u0026lt; d2) return -1; // Neither val is NaN, thisVal is smaller if (d1 \u0026gt; d2) return 1; // Neither val is NaN, thisVal is larger // Cannot use doubleToRawLongBits because of possibility of NaNs. long thisBits = Double.doubleToLongBits(d1); long anotherBits = Double.doubleToLongBits(d2); return (thisBits == anotherBits ? 0 : // Values are equal (thisBits \u0026lt; anotherBits ? -1 : // (-0.0, 0.0) or (!NaN, NaN) 1)); // (0.0, -0.0) or (NaN, !NaN) } 而实际上，要想实现只需要 Double::doubleToLongBits 方法，将 Double 转 Long\n1 2 3 4 5 6 7 8 9 private static final long MINUS_ZERO_LONG_BITS = Double.doubleToLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } 不过 Double::doubleToLongBits 也只有微不足道的性能提升，因为它会对 NaN 进行约束，NaN 会赋值为 0x7ff8000000000000L ，如果确保 abs 入参肯定是 double，则只需要取出 Double::doubleToRawLongBits\n1 2 3 4 5 6 public static long doubleToLongBits(double value) { if (!isNaN(value)) { return doubleToRawLongBits(value); } return 0x7ff8000000000000L; } 于是就变成这样实现\n1 2 3 4 5 6 7 8 9 private static final long MINUS_ZERO_LONG_BITS = Double.doubleToRawLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToRawLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } 到 JDK8 就结束了，而 JDK9 开始引入 @HotSpotIntrinsicCandidate 注解，即 HotSpot JVM 内部的 JIT compiler 会移除 JDK 中的实现方法，采用 CPU 指令直接实现，这会比高级语言转汇编转机器语言要快很多，毕竟 CPU 并不会在乎数据类型的问题，只需要重新解释(reinterpreting) 储存在 CPU 寄存器的一组位的问题，以便于与 Java 数据类型一致。\n1 2 @HotSpotIntrinsicCandidate public static native long doubleToRawLongBits(double value); 但这么实现，仍然有条件分支，如果 CPU 分支预测(branch predictor) 失误，性能开销就会增大。接下来考虑减少条件分支。\n利用 0.0 与 +/0.0 作差，都会使正负零转化为正零\n1 2 System.out.println(0.0-(-0.0)); // 0.0 System.out.println(0.0-(+0.0)); // 0.0 对方法进行改写\n1 2 3 4 5 6 7 8 9 public static double abs(double value) { if (value == 0) { return 0.0 - value; } if (value \u0026lt; 0) { return -value; } return value; } 注意到对于普通负数而言，0.0 - value 与 -value 的结果相同，所以合并分支\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt;= 0) { return 0.0 - value; } return value; } AKA\n1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0) ? 0.0 - a : a; } 会发现，JDK Math::abs(double,double) 实现相同（逃\n遵循 IEEE-754 的双精度浮点数二进制表达形式，只需要将二进制在高位符号位改成 0 即可实现转正数(abs) ，需要掩码 0x7fffffffffffffffL == 63位 1 bit\n1 System.out.println(Long.bitCount(0x7fffffffffffffffL)); // 63 最终实现 1 2 3 4 public static double abs(double value) { return Double.longBitsToDouble( Double.doubleToRawLongBits(value) \u0026amp; 0x7fffffffffffffffL); } 📌此版本不存在分支，在某些条件下的吞吐量增加 10%，单分支实现在 Java 标准库存在多年，在随即到来的 JDK 18 中，改进版本已经提交「From: 2021/9/18」\n然而在许多情况下，这些改进并没有太大意义，因为 JIT 编译器会适当使用汇编指令(if available) 会完全替代 Java code，所以这种改动并 不能 使程序显著性提升很多（逃\n🔗Reference One does not simply calculate the absolute value\nOpenJDK Double::compare\nJavaSE 8 doubleToLongBits\n","date":"2021-09-18T17:34:24+08:00","image":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/java-programming-cover_hu940919409602284940.png","permalink":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/","title":"关于设计绝对值 abs() 的一些思考"},{"content":" Java For-loop For-each Iterator 效率分析 System.nanoTime 计时测试 数量级：1,000 数量级：10,000 数量级：100,000 JMH BenchMark 基准测试 基准测试结果分析 三种循环的使用建议 For-each 优势于 While-loop 预防Bug 为什么要“将局部变量的作用域最小化” For-each 优势于 For-loop For-each 无法使用的地方 For-each 拓展使用 总结 Java For-loop For-each Iterator 效率分析 System.nanoTime 计时测试 使用 System.nanoTime() 作差计算耗时 LinkedList::get(int index) 时间复杂度为 $O(n)$，loop 中的操作必须保持一致，因此用 ArrayList 做 Iterator 的集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.util.*; public class Solution { public static final int MAGNITUDE = 10000; // 数量级 public static long testForloop(List\u0026lt;String\u0026gt; list) { long start, end; String str = null; start = System.nanoTime(); for (int i = 0; i \u0026lt; MAGNITUDE; i++) { str = list.get(i); } end = System.nanoTime(); return end - start; } public static long testForeach(List\u0026lt;String\u0026gt; list) { long start, end; String str = null; start = System.nanoTime(); for (String s : list) { str = s; } end = System.nanoTime(); return end - start; } public static long testIterator(List\u0026lt;String\u0026gt; list) { long start, end; String str = null; start = System.nanoTime(); Iterator\u0026lt;String\u0026gt; iterator = list.iterator(); while (iterator.hasNext()) { str = iterator.next(); } end = System.nanoTime(); return end - start; } public static void main(String[] args) { /* initialize */ List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; MAGNITUDE; i++) { arrayList.add(String.valueOf(i)); } System.out.println(\u0026#34;For loop: \u0026#34; + testForloop(arrayList)); System.out.println(\u0026#34;Foreach: \u0026#34; + testForeach(arrayList)); System.out.println(\u0026#34;Iterator: \u0026#34; + testIterator(arrayList)); } } 数量级：1,000 For loop: 99000\nForeach: 321700\nIterator: 194500\n数量级：10,000 For loop: 933200\nForeach: 942500\nIterator: 585800\n数量级：100,000 For loop: 3730800\nForeach: 6669800\nIterator: 5215100\n在小数量级上，For-loop 效率会高一点，For \u0026lt; Iterator \u0026lt; For-each， 这里得出的结论根据时间消耗得出，无法仔细比较效率高低，数量级小时，For-loop 效率高一点，整体来说，三者速度级别差不多。\nJMH BenchMark 基准测试 使用到 JMH 基准测试验证三种循环，数量级为百万 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import org.openjdk.jmh.annotations.*; import org.openjdk.jmh.infra.Blackhole; import org.openjdk.jmh.results.format.ResultFormatType; import org.openjdk.jmh.runner.Runner; import org.openjdk.jmh.runner.options.Options; import org.openjdk.jmh.runner.options.OptionsBuilder; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.concurrent.TimeUnit; @State(Scope.Thread) @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) @Fork(1) @Warmup(iterations = 3) @Measurement(iterations = 5) public class JavaLoopBenchMarkTest { private static final int SIZE = 1_000_000; private String[] array; private List\u0026lt;String\u0026gt; arrayList; @Setup public void setup() { array = new String[SIZE]; arrayList = new ArrayList\u0026lt;\u0026gt;(SIZE); for (int i = 0; i \u0026lt; SIZE; i++) { array[i] = String.valueOf(i); arrayList.add(array[i]); } } @Benchmark public void testForLoop(Blackhole bh) { for (int i = 0; i \u0026lt; SIZE; i++) { bh.consume(array[i]); } } @Benchmark public void testForEachLoop(Blackhole bh) { for (String s : array) { bh.consume(s); } } @Benchmark public void testIterator(Blackhole bh) { Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { bh.consume(iterator.next()); } } public static void main(String[] args) throws Exception { Options opt = new OptionsBuilder() .include(JavaLoopBenchMarkTest.class.getSimpleName()) .forks(1) .resultFormat(ResultFormatType.JSON) .result(\u0026#34;benchmark-results.json\u0026#34;) // 生成 json 报告，JMH Visual Chart 可视化分析 .build(); new Runner(opt).run(); } } 基准测试结果分析 1 2 3 4 Benchmark Mode Cnt Score Error Units JavaLoopBenchMarkTest.testForEachLoop avgt 5 143919.250 ± 8507.941 ns/op JavaLoopBenchMarkTest.testForLoop avgt 5 139981.040 ± 4770.272 ns/op JavaLoopBenchMarkTest.testIterator avgt 5 142754.313 ± 8949.872 ns/op 严格来讲三者速度几乎不相上下，硬是要说最快，应该是原生 For-loop, For-each 和 Iterator 应该是一样的\n三种循环的使用建议 《Effective Java》 第三版第 58 条中建议，一般采用 Foreach 进行循环，因为它在 简洁性和 预防Bug上优于 For-loop 和 Iterator（确切说是 Iterator 配合 while 使用）\nFor-each 优势于 While-loop 预防Bug 说到预防Bug，这里牵涉到 第57条 中的 将局部变量的作用域最小化。 为什么要“将局部变量的作用域最小化” 书中提到，原因类似于第 15 条的本质，使类和成员的可访问性最小化。\n将局部变量作用域最小化，可以增强代码的可读性和可维护性，并降低出错的可能性。\n循环中提供了特殊的机会来将变量的作用域最小化。\n无论是传统的 for 循环，还是 for-each 形式的 for 循环，都允许声明循环变量，它们的作用域被限定在正好需要的范围之内。\n如果在循环终止之后不再需要循环变量的内容，for-loop 就优先于 while-loop。\n如下是一种遍历集合的首选做法： 1 2 3 4 // Preferred idiom for iterating over a collection or array for (Element e : c) { ... // Do Someting with e } 如果需要访问迭代器，可能要调用它的 remove 方法，首选做法是利用传统的 for 循环替代 for-each 循环： 1 2 3 4 5 // Idiom for iterating when you need the iterator for (Iterator\u0026lt;Element\u0026gt; i = c.iterator(); i.hasNext(); ) { Element e = i.next(); ... // Do someting with e and i } 为什么有些时候不能用 for-each ，鉴于它是基于 Iterator 的 hasNext() + next()，有时候需要在循环过程中对集合进行操作，\n此时就必须使用 Iterator 对象进行操作了，因为使用 Iterator 循环时，集合的操作权就交给 Iterator，\n虽然可以用集合对象进行操作，如 romove() 但这样会破坏 iterator 初始化的结果，导致最终程序运行的结果与预期偏差很大\n至于为什么 for loop 要比 while loop 更好，参考一下代码片段，连续的两个 while loop，以及出现的一个 bug 1 2 3 4 5 6 7 8 9 Iterator\u0026lt;Element\u0026gt; i = c.iterator(); while (i.hasNext()) { doSometing(i.next()); } ... Iterator\u0026lt;Element\u0026gt; i2 = c.iterator(); while (i.hasNext()) { // This is bug! doSometing(i2.next()); } 在第二个 while loop 中，使用了 迭代器 i 的判断，实际操作的是 i2 迭代器对象, i 迭代器发生泄露，而不会轻易被发现，IDE 也不会报错, 所以要利用好 for loop 声明迭代器，控制它的作用范围\n上面 bug 程序最终的结果是下面的 while loop 不会执行，因为在上面的 while loop 执行结束之后，迭代器 i 就会遍历到尽头，继续判断 i.hasNext() 只会返回 false\nFor-each 优势于 For-loop 以下面一个 两层集合嵌套迭代出现的 bug 来展开讨论 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Can you spot the bug? enum Suit {CLUB, DIAMOND, HEART, SPADE} enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING } ... static Collection\u0026lt;Suit\u0026gt; suits = Arrays.asList(Suit.values()); static Collection\u0026lt;Rank\u0026gt; ranks = Arrays.asList(Rank.values()); List\u0026lt;Card\u0026gt; deck = new ArrayList\u0026lt;\u0026gt;(); for (Iterator\u0026lt;Suit\u0026gt; i = suits.iterator(); i.hasNext(); ) for (Iterator\u0026lt;Rank\u0026gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(i.next(), j.next())); bug在于，在迭代器上对外部的集合 suits 调用太多 next 方法，它应该从外部的循环进行调用，以便每种花色都调用一次，但它却是从内部循环调用，因此每次牌调用一次。在用完所有花色之后，循环就会抛出 NoSuchElementException异常。\n如果碰巧外部集合的大小是内部集合大小的几倍（可能因为它们是相同的集合），循环就会正常终止，但是实际完成情况跟预期是有出入的。\n下面是打印一对骰子出现的所有可能情况： 1 2 3 4 5 6 7 // Same bug, different symptom! enum Face {ONE, TWO, THREE, FOUR, FIVE, SIX} Collection\u0026lt;Face\u0026gt; faces = EnumSet.allOf(Face.class); for (Iterator\u0026lt;Face\u0026gt; i = faces.iterator(); i.hasNext(); ) for (Iterator\u0026lt;Face\u0026gt; j = faces.iterator(); i.hasNext(); ) System.out.println(i.next() + \u0026#34; \u0026#34; + j.next()); ONE ONE\nTWO TWO\nTHREE THREE\nFOUR FOUR\nFIVE FIVE\nSIX SIX\n同样的错误，也是重复调用 next。这种程序不会抛出异常，所以往往找 bug 会特别难受\n下面开始修正此 bug 1 2 3 4 5 6 // Fixed, but ugly - so we need for-each for (Iterator\u0026lt;Suit\u0026gt; i = suits.iterator(); i.hasNext(); ) { Suit suit = i.next(); for (Iterator\u0026lt;Rank\u0026gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(suit, j.next())); } 至此引出 for-each ，让这个问题完全消失，并且产生的代码也能很简洁。 1 2 3 4 // Preferred idiom for neat iteration on collections and arrays for (Suit suit : suits) for (Rank rank : ranks) deck.add(new Card(suit, rank)); For-each 无法使用的地方 解构过滤：如果需要遍历集合，并删除指定元素，需要使用显式的迭代器，以便使用它的 remove 方法。使用 Java 8 中添加的 Collection 的 removeIf，常常可以避免显式遍历。 转换：如果需要遍历列表或者数组，并取代它的部分或者全部元素值，就需要列表迭代器或者数组索引，以便设置元素的值。 平行迭代：如果需要并行地遍历多个集合，就需要显式地控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以同步前进（就如上述有问题的牌和骰子的示例中无意间所示范的那样） For-each 拓展使用 for-each 不止能遍历集合和数组，还能遍历实现 Iterable 接口的任何对象，只需要实现接口对应的方法即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface Iterable\u0026lt;T\u0026gt; { /** * Returns an iterator over elements of type {@code T}. * * @return an Iterator. */ Iterator\u0026lt;T\u0026gt; iterator(); default void forEach(Consumer\u0026lt;? super T\u0026gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } } 比如写一个自定义的 LinkedList 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import java.util.Iterator; import java.util.NoSuchElementException; public class SimpleList\u0026lt;T\u0026gt; implements Iterable\u0026lt;T\u0026gt; { private Node\u0026lt;T\u0026gt; head; private static class Node\u0026lt;T\u0026gt; { T data; Node\u0026lt;T\u0026gt; next; Node(T data) { this.data = data; this.next = null; } } public void add(T data) { if (head == null) { head = new Node\u0026lt;\u0026gt;(data); } else { Node\u0026lt;T\u0026gt; current = head; while (current.next != null) { current = current.next; } current.next = new Node\u0026lt;\u0026gt;(data); } } @Override public Iterator\u0026lt;T\u0026gt; iterator() { return new Iterator\u0026lt;T\u0026gt;() { private Node\u0026lt;T\u0026gt; current = head; @Override public boolean hasNext() { return current != null; } @Override public T next() { if (!hasNext()) { throw new NoSuchElementException(); } T data = current.data; current = current.next; return data; } }; } public static void main(String[] args) { SimpleList\u0026lt;String\u0026gt; list = new SimpleList\u0026lt;\u0026gt;(); list.add(\u0026#34;Hello\u0026#34;); list.add(\u0026#34;World\u0026#34;); list.add(\u0026#34;!\u0026#34;); for (String s : list) { System.out.println(s); } } } 总结 总而言之，与传统的 for 循环相比，for-each 循环在简洁性、灵活性以及出错预防性方面都占有绝对优势，并且没有性能惩罚的问题。\n因此，当可以选择的时候，for-each 循环应该优先于 for 循环。\n","date":"2021-03-16T10:37:29+08:00","image":"https://capriwits.com/post/java-for_loop_for_each_iterator-efficiency-analysis/java-programming-cover_hu940919409602284940.png","permalink":"https://capriwits.com/post/java-for_loop_for_each_iterator-efficiency-analysis/","title":"Java For-loop For-each Iterator 效率分析"},{"content":" Iterator remove 时出现 ConcurrentModificationException 前言 分析 建议用法 Iterator remove 时出现 ConcurrentModificationException 前言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;String\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;b\u0026#34;.equals(cur)) { arrayList.remove(cur); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } /*for (String s : arrayList) { if (\u0026#34;b\u0026#34;.equals(s)) { arrayList.remove(s); } else { System.out.println(s + \u0026#34; \u0026#34;); } }*/ System.out.println(arrayList); } } for-each 实际就是隐式使用 iterator 遍历集合，上面的例子会抛出异常，并删除失败。 a\nException in thread \u0026ldquo;main\u0026rdquo; java.util.ConcurrentModificationException\nat java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:937)\nat java.base/java.util.ArrayList$Itr.next(ArrayList.java:891)\nat Solution.main(Solution.java:14)\n然而删除 倒数第二个 元素却不会报错 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;c\u0026#34;.equals(cur)) { arrayList.remove(cur); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } /*for (String s : arrayList) { if (\u0026#34;c\u0026#34;.equals(s)) { arrayList.remove(s); } else { System.out.println(s + \u0026#34; \u0026#34;); } }*/ System.out.println(arrayList); } } a\nb\n[a, b, d]\n分析 首先先观察 ArrayList 的 iterator()，看迭代器怎么构造。 ArrayList 的 父类 AbstractList 中 1 2 3 public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } Itr 是里面的内部类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 private class Itr implements Iterator\u0026lt;E\u0026gt; { /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() { return cursor != size(); } public E next() { checkForComodification(); try { int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public void remove() { if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet \u0026lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } cursor：下一个要访问的元素的索引 lastRet：上一个访问的元素的索引 expectedModCount 是期望的该 List 被修改的次数，初始化为 modCount modCount 是 AbstractList 的一个成员变量。 The number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.\nThis field is used by the iterator and list iterator implementation returned by the iterator and listIterator methods. If the value of this field changes unexpectedly, the iterator (or list iterator) will throw a ConcurrentModificationException in response to the next, remove, previous, set or add operations. This provides fail-fast behavior, rather than non-deterministic behavior in the face of concurrent modification during iteration.\nUse of this field by subclasses is optional. If a subclass wishes to provide fail-fast iterators (and list iterators), then it merely has to increment this field in its add(int, E) and remove(int) methods (and any other methods that it overrides that result in structural modifications to the list). A single call to add(int, E) or remove(int) must add no more than one to this field, or the iterators (and list iterators) will throw bogus ConcurrentModificationExceptions. If an implementation does not wish to provide fail-fast iterators, this field may be ignored.\n1 protected transient int modCount = 0; 结构修改是指那些改变列表大小的修改，或者以某种方式扰乱列表，使得正在进行的迭代可能产生不正确的结果。 此字段由迭代器和 listIterator方法返回的迭代器和列表迭代器实现使用。如果此字段的值意外更改，迭代器（或列表迭代器）将抛出 ConcurrentModificationException以响应 next、remove、previous、set 或 add 操作。这提供了 快速失败 的行为。 深入 ArrayList 里观察 next() 1 2 3 4 5 6 7 8 9 10 11 public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } 1 2 3 4 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 抛出的 ConcurrentModificationException 异常是 checkForComodification() 抛出的。 条件是：modCount != expectedModCount 所以在 add remove 的过程中 modCount 会自增自减。如果用集合的 remove则 List 的 modCount减少一，而 Iterator 的 expectedModCount不变，就会抛出异常。\n至于为什么倒数第二个元素删除不会报错，我们要先了解 Iterator 遍历的特点。\nwhile + iterator 的组合是需要先判空 hasNext()，然后再 next()，最后才 remove()，否则会报错，可以自行实验，调换 next 和 remove。\n因为要先 next，将游标 越过 当前的元素，然后再决定要怎么操作当前的（游标前面的）这个元素，即游标是插在 当前元素 和 下一个元素 的中间（可以这么理解）。\n删除倒数第二个元素的时候，cursor 指向 最后一个元素，而此时删掉了倒数第二个元素后，cursor 和 size() 正好相等了，所以 hasNext() 返回 false，遍历结束，成功的删除了倒数第二个元素。\n建议用法 一个原则是，尽量在遍历的过程中不要对原集合进行增删，容易改变原结构，可以用 immutable 的思想，重新封装一个集合。\n要 remove() ，则要在 iterator() 上面来进行 remove()，因为 Iterator 迭代，就把操作权交给了 Iterator，就不要再用原集合进行操作了。\n正确用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;a\u0026#34;.equals(cur)) { iterator.remove(); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } System.out.println(arrayList); } } b\nc\nd\n[b, c, d]\n以上分析是基于 ArrayList，基于链表的 LinkedList 道理大同小异，思想不变，测试的结果也是不变的。\n","date":"2021-03-15T20:10:31+08:00","image":"https://capriwits.com/post/iterator-concurrentmodificationexception-problem-when-remove/java-programming-cover_hu940919409602284940.png","permalink":"https://capriwits.com/post/iterator-concurrentmodificationexception-problem-when-remove/","title":"Iterator remove 时出现 ConcurrentModificationException"}]