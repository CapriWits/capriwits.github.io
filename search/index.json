[{"content":"å…³äºè®¾è®¡ç»å¯¹å€¼absçš„ä¸€äº›æ€è€ƒ ã€Œå–ç»å¯¹å€¼ã€å¯¹äº Integer æ¯«æ— ç–‘é—®ç›´æ¥åˆ¤æ–­æ­£è´Ÿ\nMath::abs(int) 1 2 3 public static int abs(int a) { return (a \u0026lt; 0) ? -a : a; } æ³¨æ„åˆ°åŒç²¾åº¦æµ®ç‚¹æ•° Double å®˜æ–¹ä½¿ç”¨ä»¥ä¸‹å®ç°\nMath::abs(double) 1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0D) ? 0.0D - a : a; } Java éµå¾ª IEEE-754 æ ‡å‡†ï¼Œå› æ­¤å®ç°ä¸Šå­˜åœ¨ +0.0 \u0026amp; -0.0ï¼Œä¸¤è€…é™¤äº†æ–‡æœ¬è¡¨ç¤ºä¸åŒï¼Œåœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¹Ÿä¸åŒã€‚å¦‚ï¼š1 / +- 0.0 å¾—åˆ°çš„ç»“æœæ˜¯ +Infinity \u0026amp; -Infinity\nabs è®¡ç®—ç»“æœä»ç„¶æ˜¯è´Ÿæ•°ï¼Œå‡ºç°é”™è¯¯ï¼ŒåŸå› æ—¢æ˜¯ +0.0 == -0.0\n1 2 3 4 5 6 7 8 9 10 11 public class Solution { public static void main(String[] args) { double x = -0.0; if (1 / abs(x) \u0026lt; 0) { System.out.println(\u0026#34;abs(x) \u0026lt; 0\u0026#34;); } } public static double abs(double a) { return (a \u0026lt; 0) ? -a : a; } } å°è¯•è§£å†³é—®é¢˜ï¼Œæ·»åŠ åˆ¤æ–­æ¡ä»¶ï¼šif (val \u0026lt; 0 || val == -0.0) å¯¹ -0.0 å•ç‹¬è€ƒè™‘ï¼Œè¿›è¡ŒåŒé‡åˆ¤æ–­ï¼Œè¿™é‡Œé‡‡ç”¨ Double::compare(double, double) å®ç°\næˆåŠŸå®ç°\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt; 0 || Double.compare(value, -0.0) == 0) { return -value; } return value; } å†è¿½æ±‚æè‡´çš„ä¼˜åŒ–ã€‚æŸ¥çœ‹ Double::compare å®ç°ã€‚\nå¯¹äºæ­£æ•°è¿›è¡Œé¢å¤–çš„ä¸¤æ¬¡æ¯”è¾ƒ, å¯¹äº -0.0 è¿›è¡Œé¢å¤–çš„ ä¸‰æ¬¡ æ¯”è¾ƒ, å¯¹äº +0.0 è¿›è¡Œé¢å¤–çš„ å››æ¬¡ æ¯”è¾ƒ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static int compare(double d1, double d2) { if (d1 \u0026lt; d2) return -1; // Neither val is NaN, thisVal is smaller if (d1 \u0026gt; d2) return 1; // Neither val is NaN, thisVal is larger // Cannot use doubleToRawLongBits because of possibility of NaNs. long thisBits = Double.doubleToLongBits(d1); long anotherBits = Double.doubleToLongBits(d2); return (thisBits == anotherBits ? 0 : // Values are equal (thisBits \u0026lt; anotherBits ? -1 : // (-0.0, 0.0) or (!NaN, NaN) 1)); // (0.0, -0.0) or (NaN, !NaN) } è€Œå®é™…ä¸Šï¼Œè¦æƒ³å®ç°åªéœ€è¦ Double::doubleToLongBits æ–¹æ³•ï¼Œå°† Double è½¬ Long\n1 2 3 4 5 6 7 8 9 10 private static final long MINUS_ZERO_LONG_BITS = Double.doubleToLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } ä¸è¿‡ Double::doubleToLongBits ä¹Ÿåªæœ‰å¾®ä¸è¶³é“çš„æ€§èƒ½æå‡ï¼Œå› ä¸ºå®ƒä¼šå¯¹ NaN è¿›è¡Œçº¦æŸï¼ŒNaN ä¼šèµ‹å€¼ä¸º 0x7ff8000000000000L ï¼Œå¦‚æœç¡®ä¿ abs å…¥å‚è‚¯å®šæ˜¯ doubleï¼Œåˆ™åªéœ€è¦å–å‡º Double::doubleToRawLongBits\n1 2 3 4 5 6 public static long doubleToLongBits(double value) { if (!isNaN(value)) { return doubleToRawLongBits(value); } return 0x7ff8000000000000L; } äºæ˜¯å°±å˜æˆè¿™æ ·å®ç°\n1 2 3 4 5 6 7 8 9 private static final long MINUS_ZERO_LONG_BITS =Â Double.doubleToRawLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToRawLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } åˆ° JDK8 å°±ç»“æŸäº†ï¼Œè€Œ JDK9 å¼€å§‹å¼•å…¥ @HotSpotIntrinsicCandidate æ³¨è§£ï¼Œå³ HotSpot JVM å†…éƒ¨çš„ JIT compiler ä¼šç§»é™¤ JDK ä¸­çš„å®ç°æ–¹æ³•ï¼Œé‡‡ç”¨ CPU æŒ‡ä»¤ç›´æ¥å®ç°ï¼Œè¿™ä¼šæ¯”é«˜çº§è¯­è¨€è½¬æ±‡ç¼–è½¬æœºå™¨è¯­è¨€è¦å¿«å¾ˆå¤šï¼Œæ¯•ç«Ÿ CPU å¹¶ä¸ä¼šåœ¨ä¹æ•°æ®ç±»å‹çš„é—®é¢˜ï¼Œåªéœ€è¦é‡æ–°è§£é‡Š(reinterpreting) å‚¨å­˜åœ¨ CPU å¯„å­˜å™¨çš„ä¸€ç»„ä½çš„é—®é¢˜ï¼Œä»¥ä¾¿äºä¸ Java æ•°æ®ç±»å‹ä¸€è‡´ã€‚\n1 2 @HotSpotIntrinsicCandidate public static native long doubleToRawLongBits(double value); ä½†è¿™ä¹ˆå®ç°ï¼Œä»ç„¶æœ‰æ¡ä»¶åˆ†æ”¯ï¼Œå¦‚æœ CPU åˆ†æ”¯é¢„æµ‹(branch predictor) å¤±è¯¯ï¼Œæ€§èƒ½å¼€é”€å°±ä¼šå¢å¤§ã€‚æ¥ä¸‹æ¥è€ƒè™‘å‡å°‘æ¡ä»¶åˆ†æ”¯ã€‚\nåˆ©ç”¨ 0.0 ä¸ +/0.0 ä½œå·®ï¼Œéƒ½ä¼šä½¿æ­£è´Ÿé›¶è½¬åŒ–ä¸ºæ­£é›¶\n1 2 System.out.println(0.0 - (-0.0)); // 0.0 System.out.println(0.0 - (+0.0)); // 0.0 å¯¹æ–¹æ³•è¿›è¡Œæ”¹å†™\n1 2 3 4 5 6 7 8 9 public static double abs(double value) { if (value == 0) { return 0.0 - value; } if (value \u0026lt; 0) { return -value; } return value; } æ³¨æ„åˆ°å¯¹äºæ™®é€šè´Ÿæ•°è€Œè¨€ï¼Œ0.0 - value ä¸ -value çš„ç»“æœç›¸åŒï¼Œæ‰€ä»¥åˆå¹¶åˆ†æ”¯\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt;= 0) { return 0.0 - value; } return value; } AKA\n1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0) ? 0.0 - a : a; } ä¼šå‘ç°ï¼ŒJDK Math::abs(double,double) å®ç°ç›¸åŒï¼ˆé€ƒ\néµå¾ª IEEE-754 çš„åŒç²¾åº¦æµ®ç‚¹æ•°äºŒè¿›åˆ¶è¡¨è¾¾å½¢å¼ï¼Œåªéœ€è¦å°†äºŒè¿›åˆ¶åœ¨é«˜ä½ç¬¦å·ä½æ”¹æˆ 0 å³å¯å®ç°è½¬æ­£æ•°(abs)ï¼Œéœ€è¦æ©ç  0x7fffffffffffffffL == 63ä½ 1 bit\n1 System.out.println(Long.bitCount(0x7fffffffffffffffL)); // 63 æœ€ç»ˆå®ç° 1 2 3 4 public static double abs(double value) { return Double.longBitsToDouble( Double.doubleToRawLongBits(value) \u0026amp; 0x7fffffffffffffffL); } ğŸ“Œæ­¤ç‰ˆæœ¬ä¸å­˜åœ¨åˆ†æ”¯ï¼Œåœ¨æŸäº›æ¡ä»¶ä¸‹çš„ååé‡å¢åŠ  10%ï¼Œå•åˆ†æ”¯å®ç°åœ¨ Java æ ‡å‡†åº“å­˜åœ¨å¤šå¹´ï¼Œåœ¨éšå³åˆ°æ¥çš„ JDK 18 ä¸­ï¼Œæ”¹è¿›ç‰ˆæœ¬å·²ç»æäº¤ã€ŒFrom: 2021/9/18ã€\nç„¶è€Œåœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œè¿™äº›æ”¹è¿›å¹¶æ²¡æœ‰å¤ªå¤§æ„ä¹‰ï¼Œå› ä¸º JIT ç¼–è¯‘å™¨ä¼šé€‚å½“ä½¿ç”¨æ±‡ç¼–æŒ‡ä»¤(if available) ä¼šå®Œå…¨æ›¿ä»£ Java codeï¼Œæ‰€ä»¥è¿™ç§æ”¹åŠ¨å¹¶ ä¸èƒ½ ä½¿ç¨‹åºæ˜¾è‘—æ€§æå‡å¾ˆå¤šï¼ˆé€ƒ\nğŸ”—Reference One does not simply calculate the absolute value\nOpenJDK Double::compare\nJavaSE 8 doubleToLongBits\n","date":"2021-09-18T17:34:24+08:00","image":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/java-programming-cover_hu4193375dbb5d85283668ea46b44f9b7a_34987_120x120_fill_box_smart1_3.png","permalink":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/","title":"å…³äºè®¾è®¡ç»å¯¹å€¼ abs() çš„ä¸€äº›æ€è€ƒ"},{"content":"Java For-loop For-each Iterator æ•ˆç‡åˆ†æ System.nanoTime è®¡æ—¶æµ‹è¯• ä½¿ç”¨ System.nanoTime() ä½œå·®è®¡ç®—è€—æ—¶ LinkedList::get(int index) æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œloop ä¸­çš„æ“ä½œå¿…é¡»ä¿æŒä¸€è‡´ï¼Œå› æ­¤ç”¨ ArrayList åš Iterator çš„é›†åˆ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.util.*; public class Solution { public static final int MAGNITUDE = 10000; // æ•°é‡çº§ public static long testForloop(List\u0026lt;String\u0026gt; list) { long start, end; String str = null; start = System.nanoTime(); for (int i = 0; i \u0026lt; MAGNITUDE; i++) { str = list.get(i); } end = System.nanoTime(); return end - start; } public static long testForeach(List\u0026lt;String\u0026gt; list) { long start, end; String str = null; start = System.nanoTime(); for (String s : list) { str = s; } end = System.nanoTime(); return end - start; } public static long testIterator(List\u0026lt;String\u0026gt; list) { long start, end; String str = null; start = System.nanoTime(); Iterator\u0026lt;String\u0026gt; iterator = list.iterator(); while (iterator.hasNext()) { str = iterator.next(); } end = System.nanoTime(); return end - start; } public static void main(String[] args) { /* initialize */ List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; MAGNITUDE; i++) { arrayList.add(String.valueOf(i)); } System.out.println(\u0026#34;For loop: \u0026#34; + testForloop(arrayList)); System.out.println(\u0026#34;Foreach: \u0026#34; + testForeach(arrayList)); System.out.println(\u0026#34;Iterator: \u0026#34; + testIterator(arrayList)); } } æ•°é‡çº§ï¼š1,000 For loop: 99000\nForeach: 321700\nIterator: 194500\næ•°é‡çº§ï¼š10,000 For loop: 933200\nForeach: 942500\nIterator: 585800\næ•°é‡çº§ï¼š100,000 For loop: 3730800\nForeach: 6669800\nIterator: 5215100\nåœ¨å°æ•°é‡çº§ä¸Šï¼ŒFor-loop æ•ˆç‡ä¼šé«˜ä¸€ç‚¹ï¼ŒFor \u0026lt; Iterator \u0026lt; For-eachï¼Œ è¿™é‡Œå¾—å‡ºçš„ç»“è®ºæ ¹æ®æ—¶é—´æ¶ˆè€—å¾—å‡ºï¼Œæ— æ³•ä»”ç»†æ¯”è¾ƒæ•ˆç‡é«˜ä½ï¼Œæ•°é‡çº§å°æ—¶ï¼ŒFor-loop æ•ˆç‡é«˜ä¸€ç‚¹ï¼Œæ•´ä½“æ¥è¯´ï¼Œä¸‰è€…é€Ÿåº¦çº§åˆ«å·®ä¸å¤šã€‚\nJMH BenchMark åŸºå‡†æµ‹è¯• ä½¿ç”¨åˆ° JMH åŸºå‡†æµ‹è¯•éªŒè¯ä¸‰ç§å¾ªç¯ï¼Œæ•°é‡çº§ä¸ºç™¾ä¸‡ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import org.openjdk.jmh.annotations.*; import org.openjdk.jmh.infra.Blackhole; import org.openjdk.jmh.results.format.ResultFormatType; import org.openjdk.jmh.runner.Runner; import org.openjdk.jmh.runner.options.Options; import org.openjdk.jmh.runner.options.OptionsBuilder; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.concurrent.TimeUnit; @State(Scope.Thread) @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) @Fork(1) @Warmup(iterations = 3) @Measurement(iterations = 5) public class JavaLoopBenchMarkTest { private static final int SIZE = 1_000_000; private String[] array; private List\u0026lt;String\u0026gt; arrayList; @Setup public void setup() { array = new String[SIZE]; arrayList = new ArrayList\u0026lt;\u0026gt;(SIZE); for (int i = 0; i \u0026lt; SIZE; i++) { array[i] = String.valueOf(i); arrayList.add(array[i]); } } @Benchmark public void testForLoop(Blackhole bh) { for (int i = 0; i \u0026lt; SIZE; i++) { bh.consume(array[i]); } } @Benchmark public void testForEachLoop(Blackhole bh) { for (String s : array) { bh.consume(s); } } @Benchmark public void testIterator(Blackhole bh) { Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { bh.consume(iterator.next()); } } public static void main(String[] args) throws Exception { Options opt = new OptionsBuilder() .include(JavaLoopBenchMarkTest.class.getSimpleName()) .forks(1) .resultFormat(ResultFormatType.JSON) .result(\u0026#34;benchmark-results.json\u0026#34;) // ç”Ÿæˆ json æŠ¥å‘Šï¼ŒJMH Visual Chart å¯è§†åŒ–åˆ†æ .build(); new Runner(opt).run(); } } åŸºå‡†æµ‹è¯•ç»“æœåˆ†æ 1 2 3 4 Benchmark Mode Cnt Score Error Units JavaLoopBenchMarkTest.testForEachLoop avgt 5 143919.250 Â± 8507.941 ns/op JavaLoopBenchMarkTest.testForLoop avgt 5 139981.040 Â± 4770.272 ns/op JavaLoopBenchMarkTest.testIterator avgt 5 142754.313 Â± 8949.872 ns/op ä¸¥æ ¼æ¥è®²ä¸‰è€…é€Ÿåº¦å‡ ä¹ä¸ç›¸ä¸Šä¸‹ï¼Œç¡¬æ˜¯è¦è¯´æœ€å¿«ï¼Œåº”è¯¥æ˜¯åŸç”Ÿ For-loop, For-each å’Œ Iterator åº”è¯¥æ˜¯ä¸€æ ·çš„\nä¸‰ç§å¾ªç¯çš„ä½¿ç”¨å»ºè®® ã€ŠEffective Javaã€‹ ç¬¬ä¸‰ç‰ˆç¬¬ 58 æ¡ä¸­å»ºè®®ï¼Œä¸€èˆ¬é‡‡ç”¨ Foreach è¿›è¡Œå¾ªç¯ï¼Œå› ä¸ºå®ƒåœ¨ ç®€æ´æ€§å’Œ é¢„é˜²Bugä¸Šä¼˜äº For-loop å’Œ Iteratorï¼ˆç¡®åˆ‡è¯´æ˜¯ Iterator é…åˆ while ä½¿ç”¨ï¼‰\nFor-each ä¼˜åŠ¿äº While-loop é¢„é˜²Bug è¯´åˆ°é¢„é˜²Bugï¼Œè¿™é‡Œç‰µæ¶‰åˆ° ç¬¬57æ¡ ä¸­çš„ å°†å±€éƒ¨å˜é‡çš„ä½œç”¨åŸŸæœ€å°åŒ–ã€‚ ä¸ºä»€ä¹ˆè¦â€œå°†å±€éƒ¨å˜é‡çš„ä½œç”¨åŸŸæœ€å°åŒ–â€ ä¹¦ä¸­æåˆ°ï¼ŒåŸå› ç±»ä¼¼äºç¬¬ 15 æ¡çš„æœ¬è´¨ï¼Œä½¿ç±»å’Œæˆå‘˜çš„å¯è®¿é—®æ€§æœ€å°åŒ–ã€‚\nå°†å±€éƒ¨å˜é‡ä½œç”¨åŸŸæœ€å°åŒ–ï¼Œå¯ä»¥å¢å¼ºä»£ç çš„å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ï¼Œå¹¶é™ä½å‡ºé”™çš„å¯èƒ½æ€§ã€‚\nå¾ªç¯ä¸­æä¾›äº†ç‰¹æ®Šçš„æœºä¼šæ¥å°†å˜é‡çš„ä½œç”¨åŸŸæœ€å°åŒ–ã€‚\næ— è®ºæ˜¯ä¼ ç»Ÿçš„ for å¾ªç¯ï¼Œè¿˜æ˜¯ for-each å½¢å¼çš„ for å¾ªç¯ï¼Œéƒ½å…è®¸å£°æ˜å¾ªç¯å˜é‡ï¼Œå®ƒä»¬çš„ä½œç”¨åŸŸè¢«é™å®šåœ¨æ­£å¥½éœ€è¦çš„èŒƒå›´ä¹‹å†…ã€‚\nå¦‚æœåœ¨å¾ªç¯ç»ˆæ­¢ä¹‹åä¸å†éœ€è¦å¾ªç¯å˜é‡çš„å†…å®¹ï¼Œfor-loop å°±ä¼˜å…ˆäº while-loopã€‚\nå¦‚ä¸‹æ˜¯ä¸€ç§éå†é›†åˆçš„é¦–é€‰åšæ³•ï¼š 1 2 3 4 // Preferred idiom for iterating over a collection or array for (Element e : c) { ... // Do Someting with e } å¦‚æœéœ€è¦è®¿é—®è¿­ä»£å™¨ï¼Œå¯èƒ½è¦è°ƒç”¨å®ƒçš„ remove æ–¹æ³•ï¼Œé¦–é€‰åšæ³•æ˜¯åˆ©ç”¨ä¼ ç»Ÿçš„ for å¾ªç¯æ›¿ä»£ for-each å¾ªç¯ï¼š 1 2 3 4 5 // Idiom for iterating when you need the iterator for (Iterator\u0026lt;Element\u0026gt; i = c.iterator(); i.hasNext(); ) { Element e = i.next(); ... // Do someting with e and i } ä¸ºä»€ä¹ˆæœ‰äº›æ—¶å€™ä¸èƒ½ç”¨ for-each ï¼Œé‰´äºå®ƒæ˜¯åŸºäº Iterator çš„ hasNext() + next()ï¼Œæœ‰æ—¶å€™éœ€è¦åœ¨å¾ªç¯è¿‡ç¨‹ä¸­å¯¹é›†åˆè¿›è¡Œæ“ä½œï¼Œ\næ­¤æ—¶å°±å¿…é¡»ä½¿ç”¨ Iterator å¯¹è±¡è¿›è¡Œæ“ä½œäº†ï¼Œå› ä¸ºä½¿ç”¨ Iterator å¾ªç¯æ—¶ï¼Œé›†åˆçš„æ“ä½œæƒå°±äº¤ç»™ Iteratorï¼Œ\nè™½ç„¶å¯ä»¥ç”¨é›†åˆå¯¹è±¡è¿›è¡Œæ“ä½œï¼Œå¦‚ romove() ä½†è¿™æ ·ä¼šç ´å iterator åˆå§‹åŒ–çš„ç»“æœï¼Œå¯¼è‡´æœ€ç»ˆç¨‹åºè¿è¡Œçš„ç»“æœä¸é¢„æœŸåå·®å¾ˆå¤§\nè‡³äºä¸ºä»€ä¹ˆ for loop è¦æ¯” while loop æ›´å¥½ï¼Œå‚è€ƒä¸€ä¸‹ä»£ç ç‰‡æ®µï¼Œè¿ç»­çš„ä¸¤ä¸ª while loopï¼Œä»¥åŠå‡ºç°çš„ä¸€ä¸ª bug 1 2 3 4 5 6 7 8 9 Iterator\u0026lt;Element\u0026gt; i = c.iterator(); while (i.hasNext()) { doSometing(i.next()); } ... Iterator\u0026lt;Element\u0026gt; i2 = c.iterator(); while (i.hasNext()) { // This is bug! doSometing(i2.next()); } åœ¨ç¬¬äºŒä¸ª while loop ä¸­ï¼Œä½¿ç”¨äº† è¿­ä»£å™¨ i çš„åˆ¤æ–­ï¼Œå®é™…æ“ä½œçš„æ˜¯ i2 è¿­ä»£å™¨å¯¹è±¡, i è¿­ä»£å™¨å‘ç”Ÿæ³„éœ²ï¼Œè€Œä¸ä¼šè½»æ˜“è¢«å‘ç°ï¼ŒIDE ä¹Ÿä¸ä¼šæŠ¥é”™, æ‰€ä»¥è¦åˆ©ç”¨å¥½ for loop å£°æ˜è¿­ä»£å™¨ï¼Œæ§åˆ¶å®ƒçš„ä½œç”¨èŒƒå›´\nä¸Šé¢ bug ç¨‹åºæœ€ç»ˆçš„ç»“æœæ˜¯ä¸‹é¢çš„ while loop ä¸ä¼šæ‰§è¡Œï¼Œå› ä¸ºåœ¨ä¸Šé¢çš„ while loop æ‰§è¡Œç»“æŸä¹‹åï¼Œè¿­ä»£å™¨ i å°±ä¼šéå†åˆ°å°½å¤´ï¼Œç»§ç»­åˆ¤æ–­ i.hasNext() åªä¼šè¿”å› false\nFor-each ä¼˜åŠ¿äº For-loop ä»¥ä¸‹é¢ä¸€ä¸ª ä¸¤å±‚é›†åˆåµŒå¥—è¿­ä»£å‡ºç°çš„ bug æ¥å±•å¼€è®¨è®º 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Can you spot the bug? enum Suit {CLUB, DIAMOND, HEART, SPADE} enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING } ... static Collection\u0026lt;Suit\u0026gt; suits = Arrays.asList(Suit.values()); static Collection\u0026lt;Rank\u0026gt; ranks = Arrays.asList(Rank.values()); List\u0026lt;Card\u0026gt; deck = new ArrayList\u0026lt;\u0026gt;(); for (Iterator\u0026lt;Suit\u0026gt; i = suits.iterator(); i.hasNext(); ) for (Iterator\u0026lt;Rank\u0026gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(i.next(), j.next())); bugåœ¨äºï¼Œåœ¨è¿­ä»£å™¨ä¸Šå¯¹å¤–éƒ¨çš„é›†åˆ suits è°ƒç”¨å¤ªå¤š next æ–¹æ³•ï¼Œå®ƒåº”è¯¥ä»å¤–éƒ¨çš„å¾ªç¯è¿›è¡Œè°ƒç”¨ï¼Œä»¥ä¾¿æ¯ç§èŠ±è‰²éƒ½è°ƒç”¨ä¸€æ¬¡ï¼Œä½†å®ƒå´æ˜¯ä»å†…éƒ¨å¾ªç¯è°ƒç”¨ï¼Œå› æ­¤æ¯æ¬¡ç‰Œè°ƒç”¨ä¸€æ¬¡ã€‚åœ¨ç”¨å®Œæ‰€æœ‰èŠ±è‰²ä¹‹åï¼Œå¾ªç¯å°±ä¼šæŠ›å‡º NoSuchElementExceptionå¼‚å¸¸ã€‚\nå¦‚æœç¢°å·§å¤–éƒ¨é›†åˆçš„å¤§å°æ˜¯å†…éƒ¨é›†åˆå¤§å°çš„å‡ å€ï¼ˆå¯èƒ½å› ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„é›†åˆï¼‰ï¼Œå¾ªç¯å°±ä¼šæ­£å¸¸ç»ˆæ­¢ï¼Œä½†æ˜¯å®é™…å®Œæˆæƒ…å†µè·Ÿé¢„æœŸæ˜¯æœ‰å‡ºå…¥çš„ã€‚\nä¸‹é¢æ˜¯æ‰“å°ä¸€å¯¹éª°å­å‡ºç°çš„æ‰€æœ‰å¯èƒ½æƒ…å†µï¼š 1 2 3 4 5 6 7 // Same bug, different symptom! enum Face {ONE, TWO, THREE, FOUR, FIVE, SIX} Collection\u0026lt;Face\u0026gt; faces = EnumSet.allOf(Face.class); for (Iterator\u0026lt;Face\u0026gt; i = faces.iterator(); i.hasNext(); ) for (Iterator\u0026lt;Face\u0026gt; j = faces.iterator(); i.hasNext(); ) System.out.println(i.next() + \u0026#34; \u0026#34; + j.next()); ONE ONE\nTWO TWO\nTHREE THREE\nFOUR FOUR\nFIVE FIVE\nSIX SIX\nåŒæ ·çš„é”™è¯¯ï¼Œä¹Ÿæ˜¯é‡å¤è°ƒç”¨ nextã€‚è¿™ç§ç¨‹åºä¸ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œæ‰€ä»¥å¾€å¾€æ‰¾ bug ä¼šç‰¹åˆ«éš¾å—\nä¸‹é¢å¼€å§‹ä¿®æ­£æ­¤ bug 1 2 3 4 5 6 // Fixed, but ugly - so we need for-each for (Iterator\u0026lt;Suit\u0026gt; i = suits.iterator(); i.hasNext(); ) { Suit suit = i.next(); for (Iterator\u0026lt;Rank\u0026gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(suit, j.next())); } è‡³æ­¤å¼•å‡º for-each ï¼Œè®©è¿™ä¸ªé—®é¢˜å®Œå…¨æ¶ˆå¤±ï¼Œå¹¶ä¸”äº§ç”Ÿçš„ä»£ç ä¹Ÿèƒ½å¾ˆç®€æ´ã€‚ 1 2 3 4 // Preferred idiom for neat iteration on collections and arrays for (Suit suit : suits) for (Rank rank : ranks) deck.add(new Card(suit, rank)); For-each æ— æ³•ä½¿ç”¨çš„åœ°æ–¹ è§£æ„è¿‡æ»¤ï¼šå¦‚æœéœ€è¦éå†é›†åˆï¼Œå¹¶åˆ é™¤æŒ‡å®šå…ƒç´ ï¼Œéœ€è¦ä½¿ç”¨æ˜¾å¼çš„è¿­ä»£å™¨ï¼Œä»¥ä¾¿ä½¿ç”¨å®ƒçš„ remove æ–¹æ³•ã€‚ä½¿ç”¨ Java 8 ä¸­æ·»åŠ çš„ Collection çš„ removeIfï¼Œå¸¸å¸¸å¯ä»¥é¿å…æ˜¾å¼éå†ã€‚ è½¬æ¢ï¼šå¦‚æœéœ€è¦éå†åˆ—è¡¨æˆ–è€…æ•°ç»„ï¼Œå¹¶å–ä»£å®ƒçš„éƒ¨åˆ†æˆ–è€…å…¨éƒ¨å…ƒç´ å€¼ï¼Œå°±éœ€è¦åˆ—è¡¨è¿­ä»£å™¨æˆ–è€…æ•°ç»„ç´¢å¼•ï¼Œä»¥ä¾¿è®¾ç½®å…ƒç´ çš„å€¼ã€‚ å¹³è¡Œè¿­ä»£ï¼šå¦‚æœéœ€è¦å¹¶è¡Œåœ°éå†å¤šä¸ªé›†åˆï¼Œå°±éœ€è¦æ˜¾å¼åœ°æ§åˆ¶è¿­ä»£å™¨æˆ–è€…ç´¢å¼•å˜é‡ï¼Œä»¥ä¾¿æ‰€æœ‰è¿­ä»£å™¨æˆ–è€…ç´¢å¼•å˜é‡éƒ½å¯ä»¥åŒæ­¥å‰è¿›ï¼ˆå°±å¦‚ä¸Šè¿°æœ‰é—®é¢˜çš„ç‰Œå’Œéª°å­çš„ç¤ºä¾‹ä¸­æ— æ„é—´æ‰€ç¤ºèŒƒçš„é‚£æ ·ï¼‰ For-each æ‹“å±•ä½¿ç”¨ for-each ä¸æ­¢èƒ½éå†é›†åˆå’Œæ•°ç»„ï¼Œè¿˜èƒ½éå†å®ç° Iterable æ¥å£çš„ä»»ä½•å¯¹è±¡ï¼Œåªéœ€è¦å®ç°æ¥å£å¯¹åº”çš„æ–¹æ³•å³å¯ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface Iterable\u0026lt;T\u0026gt; { /** * Returns an iterator over elements of type {@code T}. * * @return an Iterator. */ Iterator\u0026lt;T\u0026gt; iterator(); default void forEach(Consumer\u0026lt;? super T\u0026gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } } æ¯”å¦‚å†™ä¸€ä¸ªè‡ªå®šä¹‰çš„ LinkedList 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import java.util.Iterator; import java.util.NoSuchElementException; public class SimpleList\u0026lt;T\u0026gt; implements Iterable\u0026lt;T\u0026gt; { private Node\u0026lt;T\u0026gt; head; private static class Node\u0026lt;T\u0026gt; { T data; Node\u0026lt;T\u0026gt; next; Node(T data) { this.data = data; this.next = null; } } public void add(T data) { if (head == null) { head = new Node\u0026lt;\u0026gt;(data); } else { Node\u0026lt;T\u0026gt; current = head; while (current.next != null) { current = current.next; } current.next = new Node\u0026lt;\u0026gt;(data); } } @Override public Iterator\u0026lt;T\u0026gt; iterator() { return new Iterator\u0026lt;T\u0026gt;() { private Node\u0026lt;T\u0026gt; current = head; @Override public boolean hasNext() { return current != null; } @Override public T next() { if (!hasNext()) { throw new NoSuchElementException(); } T data = current.data; current = current.next; return data; } }; } public static void main(String[] args) { SimpleList\u0026lt;String\u0026gt; list = new SimpleList\u0026lt;\u0026gt;(); list.add(\u0026#34;Hello\u0026#34;); list.add(\u0026#34;World\u0026#34;); list.add(\u0026#34;!\u0026#34;); for (String s : list) { System.out.println(s); } } } æ€»ç»“ æ€»è€Œè¨€ä¹‹ï¼Œä¸ä¼ ç»Ÿçš„ for å¾ªç¯ç›¸æ¯”ï¼Œfor-each å¾ªç¯åœ¨ç®€æ´æ€§ã€çµæ´»æ€§ä»¥åŠå‡ºé”™é¢„é˜²æ€§æ–¹é¢éƒ½å æœ‰ç»å¯¹ä¼˜åŠ¿ï¼Œå¹¶ä¸”æ²¡æœ‰æ€§èƒ½æƒ©ç½šçš„é—®é¢˜ã€‚\nå› æ­¤ï¼Œå½“å¯ä»¥é€‰æ‹©çš„æ—¶å€™ï¼Œfor-each å¾ªç¯åº”è¯¥ä¼˜å…ˆäº for å¾ªç¯ã€‚\n","date":"2021-03-16T10:37:29+08:00","image":"https://capriwits.com/post/java-for_loop_for_each_iterator-efficiency-analysis/java-programming-cover_hu4193375dbb5d85283668ea46b44f9b7a_34987_120x120_fill_box_smart1_3.png","permalink":"https://capriwits.com/post/java-for_loop_for_each_iterator-efficiency-analysis/","title":"Java For-loop For-each Iterator æ•ˆç‡åˆ†æ"},{"content":"Iterator remove æ—¶å‡ºç° ConcurrentModificationException å‰è¨€ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;String\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;b\u0026#34;.equals(cur)) { arrayList.remove(cur); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } /*for (String s : arrayList) { if (\u0026#34;b\u0026#34;.equals(s)) { arrayList.remove(s); } else { System.out.println(s + \u0026#34; \u0026#34;); } }*/ System.out.println(arrayList); } } for-each å®é™…å°±æ˜¯éšå¼ä½¿ç”¨ iterator éå†é›†åˆï¼Œä¸Šé¢çš„ä¾‹å­ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œå¹¶åˆ é™¤å¤±è´¥ã€‚ a\nException in thread \u0026ldquo;main\u0026rdquo; java.util.ConcurrentModificationException\nat java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:937)\nat java.base/java.util.ArrayList$Itr.next(ArrayList.java:891)\nat Solution.main(Solution.java:14)\nç„¶è€Œåˆ é™¤ å€’æ•°ç¬¬äºŒä¸ª å…ƒç´ å´ä¸ä¼šæŠ¥é”™ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;c\u0026#34;.equals(cur)) { arrayList.remove(cur); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } /*for (String s : arrayList) { if (\u0026#34;c\u0026#34;.equals(s)) { arrayList.remove(s); } else { System.out.println(s + \u0026#34; \u0026#34;); } }*/ System.out.println(arrayList); } } a\nb\n[a, b, d]\nåˆ†æ é¦–å…ˆå…ˆè§‚å¯Ÿ ArrayList çš„ iterator()ï¼Œçœ‹è¿­ä»£å™¨æ€ä¹ˆæ„é€ ã€‚ ArrayList çš„ çˆ¶ç±» AbstractList ä¸­ 1 2 3 public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } Itr æ˜¯é‡Œé¢çš„å†…éƒ¨ç±» 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 private class Itr implements Iterator\u0026lt;E\u0026gt; { /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() { return cursor != size(); } public E next() { checkForComodification(); try { int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public void remove() { if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet \u0026lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } cursorï¼šä¸‹ä¸€ä¸ªè¦è®¿é—®çš„å…ƒç´ çš„ç´¢å¼• lastRetï¼šä¸Šä¸€ä¸ªè®¿é—®çš„å…ƒç´ çš„ç´¢å¼• expectedModCount æ˜¯æœŸæœ›çš„è¯¥ List è¢«ä¿®æ”¹çš„æ¬¡æ•°ï¼Œåˆå§‹åŒ–ä¸º modCount modCount æ˜¯ AbstractList çš„ä¸€ä¸ªæˆå‘˜å˜é‡ã€‚ The number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.\nThis field is used by the iterator and list iterator implementation returned by the iterator and listIterator methods. If the value of this field changes unexpectedly, the iterator (or list iterator) will throw a ConcurrentModificationException in response to the next, remove, previous, set or add operations. This provides fail-fast behavior, rather than non-deterministic behavior in the face of concurrent modification during iteration.\nUse of this field by subclasses is optional. If a subclass wishes to provide fail-fast iterators (and list iterators), then it merely has to increment this field in its add(int, E) and remove(int) methods (and any other methods that it overrides that result in structural modifications to the list). A single call to add(int, E) or remove(int) must add no more than one to this field, or the iterators (and list iterators) will throw bogus ConcurrentModificationExceptions. If an implementation does not wish to provide fail-fast iterators, this field may be ignored.\n1 protected transient int modCount = 0; ç»“æ„ä¿®æ”¹æ˜¯æŒ‡é‚£äº›æ”¹å˜åˆ—è¡¨å¤§å°çš„ä¿®æ”¹ï¼Œæˆ–è€…ä»¥æŸç§æ–¹å¼æ‰°ä¹±åˆ—è¡¨ï¼Œä½¿å¾—æ­£åœ¨è¿›è¡Œçš„è¿­ä»£å¯èƒ½äº§ç”Ÿä¸æ­£ç¡®çš„ç»“æœã€‚ æ­¤å­—æ®µç”±è¿­ä»£å™¨å’Œ listIteratoræ–¹æ³•è¿”å›çš„è¿­ä»£å™¨å’Œåˆ—è¡¨è¿­ä»£å™¨å®ç°ä½¿ç”¨ã€‚å¦‚æœæ­¤å­—æ®µçš„å€¼æ„å¤–æ›´æ”¹ï¼Œè¿­ä»£å™¨ï¼ˆæˆ–åˆ—è¡¨è¿­ä»£å™¨ï¼‰å°†æŠ›å‡º ConcurrentModificationExceptionä»¥å“åº” nextã€removeã€previousã€set æˆ– add æ“ä½œã€‚è¿™æä¾›äº† å¿«é€Ÿå¤±è´¥ çš„è¡Œä¸ºã€‚ æ·±å…¥ ArrayList é‡Œè§‚å¯Ÿ next() 1 2 3 4 5 6 7 8 9 10 11 public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } 1 2 3 4 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } æŠ›å‡ºçš„ ConcurrentModificationException å¼‚å¸¸æ˜¯ checkForComodification() æŠ›å‡ºçš„ã€‚ æ¡ä»¶æ˜¯ï¼šmodCount != expectedModCount æ‰€ä»¥åœ¨ add remove çš„è¿‡ç¨‹ä¸­ modCount ä¼šè‡ªå¢è‡ªå‡ã€‚å¦‚æœç”¨é›†åˆçš„ removeåˆ™ List çš„ modCountå‡å°‘ä¸€ï¼Œè€Œ Iterator çš„ expectedModCountä¸å˜ï¼Œå°±ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚\nè‡³äºä¸ºä»€ä¹ˆå€’æ•°ç¬¬äºŒä¸ªå…ƒç´ åˆ é™¤ä¸ä¼šæŠ¥é”™ï¼Œæˆ‘ä»¬è¦å…ˆäº†è§£ Iterator éå†çš„ç‰¹ç‚¹ã€‚\nwhile + iterator çš„ç»„åˆæ˜¯éœ€è¦å…ˆåˆ¤ç©º hasNext()ï¼Œç„¶åå† next()ï¼Œæœ€åæ‰ remove()ï¼Œå¦åˆ™ä¼šæŠ¥é”™ï¼Œå¯ä»¥è‡ªè¡Œå®éªŒï¼Œè°ƒæ¢ next å’Œ removeã€‚\nå› ä¸ºè¦å…ˆ nextï¼Œå°†æ¸¸æ ‡ è¶Šè¿‡ å½“å‰çš„å…ƒç´ ï¼Œç„¶åå†å†³å®šè¦æ€ä¹ˆæ“ä½œå½“å‰çš„ï¼ˆæ¸¸æ ‡å‰é¢çš„ï¼‰è¿™ä¸ªå…ƒç´ ï¼Œå³æ¸¸æ ‡æ˜¯æ’åœ¨ å½“å‰å…ƒç´  å’Œ ä¸‹ä¸€ä¸ªå…ƒç´  çš„ä¸­é—´ï¼ˆå¯ä»¥è¿™ä¹ˆç†è§£ï¼‰ã€‚\nåˆ é™¤å€’æ•°ç¬¬äºŒä¸ªå…ƒç´ çš„æ—¶å€™ï¼Œcursor æŒ‡å‘ æœ€åä¸€ä¸ªå…ƒç´ ï¼Œè€Œæ­¤æ—¶åˆ æ‰äº†å€’æ•°ç¬¬äºŒä¸ªå…ƒç´ åï¼Œcursor å’Œ size() æ­£å¥½ç›¸ç­‰äº†ï¼Œæ‰€ä»¥ hasNext() è¿”å› falseï¼Œéå†ç»“æŸï¼ŒæˆåŠŸçš„åˆ é™¤äº†å€’æ•°ç¬¬äºŒä¸ªå…ƒç´ ã€‚\nå»ºè®®ç”¨æ³• ä¸€ä¸ªåŸåˆ™æ˜¯ï¼Œå°½é‡åœ¨éå†çš„è¿‡ç¨‹ä¸­ä¸è¦å¯¹åŸé›†åˆè¿›è¡Œå¢åˆ ï¼Œå®¹æ˜“æ”¹å˜åŸç»“æ„ï¼Œå¯ä»¥ç”¨ immutable çš„æ€æƒ³ï¼Œé‡æ–°å°è£…ä¸€ä¸ªé›†åˆã€‚\nè¦ remove() ï¼Œåˆ™è¦åœ¨ iterator() ä¸Šé¢æ¥è¿›è¡Œ remove()ï¼Œå› ä¸º Iterator è¿­ä»£ï¼Œå°±æŠŠæ“ä½œæƒäº¤ç»™äº† Iteratorï¼Œå°±ä¸è¦å†ç”¨åŸé›†åˆè¿›è¡Œæ“ä½œäº†ã€‚\næ­£ç¡®ç”¨æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;a\u0026#34;.equals(cur)) { iterator.remove(); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } System.out.println(arrayList); } } b\nc\nd\n[b, c, d]\nä»¥ä¸Šåˆ†ææ˜¯åŸºäº ArrayListï¼ŒåŸºäºé“¾è¡¨çš„ LinkedList é“ç†å¤§åŒå°å¼‚ï¼Œæ€æƒ³ä¸å˜ï¼Œæµ‹è¯•çš„ç»“æœä¹Ÿæ˜¯ä¸å˜çš„ã€‚\n","date":"2021-03-15T20:10:31+08:00","image":"https://capriwits.com/post/iterator-concurrentmodificationexception-problem-when-remove/java-programming-cover_hu4193375dbb5d85283668ea46b44f9b7a_34987_120x120_fill_box_smart1_3.png","permalink":"https://capriwits.com/post/iterator-concurrentmodificationexception-problem-when-remove/","title":"Iterator remove æ—¶å‡ºç° ConcurrentModificationException"}]