[{"content":"å…³äºè®¾è®¡ç»å¯¹å€¼absçš„ä¸€äº›æ€è€ƒ ã€Œå–ç»å¯¹å€¼ã€å¯¹äº Integer æ¯«æ— ç–‘é—®ç›´æ¥åˆ¤æ–­æ­£è´Ÿ\nMath::abs(int) 1 2 3 public static int abs(int a) { return (a \u0026lt; 0) ? -a : a; } æ³¨æ„åˆ°åŒç²¾åº¦æµ®ç‚¹æ•° Double å®˜æ–¹ä½¿ç”¨ä»¥ä¸‹å®ç°\nMath::abs(double) 1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0D) ? 0.0D - a : a; } Java éµå¾ª IEEE-754 æ ‡å‡†ï¼Œå› æ­¤å®ç°ä¸Šå­˜åœ¨ +0.0 \u0026amp; -0.0ï¼Œä¸¤è€…é™¤äº†æ–‡æœ¬è¡¨ç¤ºä¸åŒï¼Œåœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¹Ÿä¸åŒã€‚å¦‚ï¼š1 / +- 0.0 å¾—åˆ°çš„ç»“æœæ˜¯ +Infinity \u0026amp; -Infinity\nabs è®¡ç®—ç»“æœä»ç„¶æ˜¯è´Ÿæ•°ï¼Œå‡ºç°é”™è¯¯ï¼ŒåŸå› æ—¢æ˜¯ +0.0 == -0.0\n1 2 3 4 5 6 7 8 9 10 11 public class Solution { public static void main(String[] args) { double x = -0.0; if (1 / abs(x) \u0026lt; 0) { System.out.println(\u0026#34;abs(x) \u0026lt; 0\u0026#34;); } } public static double abs(double a) { return (a \u0026lt; 0) ? -a : a; } } å°è¯•è§£å†³é—®é¢˜ï¼Œæ·»åŠ åˆ¤æ–­æ¡ä»¶ï¼šif (val \u0026lt; 0 || val == -0.0) å¯¹ -0.0 å•ç‹¬è€ƒè™‘ï¼Œè¿›è¡ŒåŒé‡åˆ¤æ–­ï¼Œè¿™é‡Œé‡‡ç”¨ Double::compare(double, double) å®ç°\næˆåŠŸå®ç°\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt; 0 || Double.compare(value, -0.0) == 0) { return -value; } return value; } å†è¿½æ±‚æè‡´çš„ä¼˜åŒ–ã€‚æŸ¥çœ‹ Double::compare å®ç°ã€‚\nå¯¹äºæ­£æ•°è¿›è¡Œé¢å¤–çš„ä¸¤æ¬¡æ¯”è¾ƒ, å¯¹äº -0.0 è¿›è¡Œé¢å¤–çš„ ä¸‰æ¬¡ æ¯”è¾ƒ, å¯¹äº +0.0 è¿›è¡Œé¢å¤–çš„ å››æ¬¡ æ¯”è¾ƒ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static int compare(double d1, double d2) { if (d1 \u0026lt; d2) return -1; // Neither val is NaN, thisVal is smaller if (d1 \u0026gt; d2) return 1; // Neither val is NaN, thisVal is larger // Cannot use doubleToRawLongBits because of possibility of NaNs. long thisBits = Double.doubleToLongBits(d1); long anotherBits = Double.doubleToLongBits(d2); return (thisBits == anotherBits ? 0 : // Values are equal (thisBits \u0026lt; anotherBits ? -1 : // (-0.0, 0.0) or (!NaN, NaN) 1)); // (0.0, -0.0) or (NaN, !NaN) } è€Œå®é™…ä¸Šï¼Œè¦æƒ³å®ç°åªéœ€è¦ Double::doubleToLongBits æ–¹æ³•ï¼Œå°† Double è½¬ Long\n1 2 3 4 5 6 7 8 9 10 private static final long MINUS_ZERO_LONG_BITS = Double.doubleToLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } ä¸è¿‡ Double::doubleToLongBits ä¹Ÿåªæœ‰å¾®ä¸è¶³é“çš„æ€§èƒ½æå‡ï¼Œå› ä¸ºå®ƒä¼šå¯¹ NaN è¿›è¡Œçº¦æŸï¼ŒNaN ä¼šèµ‹å€¼ä¸º 0x7ff8000000000000L ï¼Œå¦‚æœç¡®ä¿ abs å…¥å‚è‚¯å®šæ˜¯ doubleï¼Œåˆ™åªéœ€è¦å–å‡º Double::doubleToRawLongBits\n1 2 3 4 5 6 public static long doubleToLongBits(double value) { if (!isNaN(value)) { return doubleToRawLongBits(value); } return 0x7ff8000000000000L; } äºæ˜¯å°±å˜æˆè¿™æ ·å®ç°\n1 2 3 4 5 6 7 8 9 private static final long MINUS_ZERO_LONG_BITS =Â Double.doubleToRawLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToRawLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } åˆ° JDK8 å°±ç»“æŸäº†ï¼Œè€Œ JDK9 å¼€å§‹å¼•å…¥ @HotSpotIntrinsicCandidate æ³¨è§£ï¼Œå³ HotSpot JVM å†…éƒ¨çš„ JIT compiler ä¼šç§»é™¤ JDK ä¸­çš„å®ç°æ–¹æ³•ï¼Œé‡‡ç”¨ CPU æŒ‡ä»¤ç›´æ¥å®ç°ï¼Œè¿™ä¼šæ¯”é«˜çº§è¯­è¨€è½¬æ±‡ç¼–è½¬æœºå™¨è¯­è¨€è¦å¿«å¾ˆå¤šï¼Œæ¯•ç«Ÿ CPU å¹¶ä¸ä¼šåœ¨ä¹æ•°æ®ç±»å‹çš„é—®é¢˜ï¼Œåªéœ€è¦é‡æ–°è§£é‡Š(reinterpreting) å‚¨å­˜åœ¨ CPU å¯„å­˜å™¨çš„ä¸€ç»„ä½çš„é—®é¢˜ï¼Œä»¥ä¾¿äºä¸ Java æ•°æ®ç±»å‹ä¸€è‡´ã€‚\n1 2 @HotSpotIntrinsicCandidate public static native long doubleToRawLongBits(double value); ä½†è¿™ä¹ˆå®ç°ï¼Œä»ç„¶æœ‰æ¡ä»¶åˆ†æ”¯ï¼Œå¦‚æœ CPU åˆ†æ”¯é¢„æµ‹(branch predictor) å¤±è¯¯ï¼Œæ€§èƒ½å¼€é”€å°±ä¼šå¢å¤§ã€‚æ¥ä¸‹æ¥è€ƒè™‘å‡å°‘æ¡ä»¶åˆ†æ”¯ã€‚\nåˆ©ç”¨ 0.0 ä¸ +/0.0 ä½œå·®ï¼Œéƒ½ä¼šä½¿æ­£è´Ÿé›¶è½¬åŒ–ä¸ºæ­£é›¶\n1 2 System.out.println(0.0 - (-0.0)); // 0.0 System.out.println(0.0 - (+0.0)); // 0.0 å¯¹æ–¹æ³•è¿›è¡Œæ”¹å†™\n1 2 3 4 5 6 7 8 9 public static double abs(double value) { if (value == 0) { return 0.0 - value; } if (value \u0026lt; 0) { return -value; } return value; } æ³¨æ„åˆ°å¯¹äºæ™®é€šè´Ÿæ•°è€Œè¨€ï¼Œ0.0 - value ä¸ -value çš„ç»“æœç›¸åŒï¼Œæ‰€ä»¥åˆå¹¶åˆ†æ”¯\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt;= 0) { return 0.0 - value; } return value; } AKA\n1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0) ? 0.0 - a : a; } ä¼šå‘ç°ï¼ŒJDK Math::abs(double,double) å®ç°ç›¸åŒï¼ˆé€ƒ\néµå¾ª IEEE-754 çš„åŒç²¾åº¦æµ®ç‚¹æ•°äºŒè¿›åˆ¶è¡¨è¾¾å½¢å¼ï¼Œåªéœ€è¦å°†äºŒè¿›åˆ¶åœ¨é«˜ä½ç¬¦å·ä½æ”¹æˆ 0 å³å¯å®ç°è½¬æ­£æ•°(abs)ï¼Œéœ€è¦æ©ç  0x7fffffffffffffffL == 63ä½ 1 bit\n1 System.out.println(Long.bitCount(0x7fffffffffffffffL)); // 63 æœ€ç»ˆå®ç° 1 2 3 4 public static double abs(double value) { return Double.longBitsToDouble( Double.doubleToRawLongBits(value) \u0026amp; 0x7fffffffffffffffL); } ğŸ“Œæ­¤ç‰ˆæœ¬ä¸å­˜åœ¨åˆ†æ”¯ï¼Œåœ¨æŸäº›æ¡ä»¶ä¸‹çš„ååé‡å¢åŠ  10%ï¼Œå•åˆ†æ”¯å®ç°åœ¨ Java æ ‡å‡†åº“å­˜åœ¨å¤šå¹´ï¼Œåœ¨éšå³åˆ°æ¥çš„ JDK 18 ä¸­ï¼Œæ”¹è¿›ç‰ˆæœ¬å·²ç»æäº¤ã€ŒFrom: 2021/9/18ã€\nç„¶è€Œåœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œè¿™äº›æ”¹è¿›å¹¶æ²¡æœ‰å¤ªå¤§æ„ä¹‰ï¼Œå› ä¸º JIT ç¼–è¯‘å™¨ä¼šé€‚å½“ä½¿ç”¨æ±‡ç¼–æŒ‡ä»¤(if available) ä¼šå®Œå…¨æ›¿ä»£ Java codeï¼Œæ‰€ä»¥è¿™ç§æ”¹åŠ¨å¹¶ ä¸èƒ½ ä½¿ç¨‹åºæ˜¾è‘—æ€§æå‡å¾ˆå¤šï¼ˆé€ƒ\nğŸ”—Reference One does not simply calculate the absolute value\nOpenJDK Double::compare\nJavaSE 8 doubleToLongBits\n","date":"2021-09-18T17:34:24+08:00","image":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/java-programming-cover_hu4193375dbb5d85283668ea46b44f9b7a_34987_120x120_fill_box_smart1_3.png","permalink":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/","title":"å…³äºè®¾è®¡ç»å¯¹å€¼ abs() çš„ä¸€äº›æ€è€ƒ"},{"content":"Iterator remove æ—¶å‡ºç° ConcurrentModificationException å‰è¨€ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;String\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;b\u0026#34;.equals(cur)) { arrayList.remove(cur); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } /*for (String s : arrayList) { if (\u0026#34;b\u0026#34;.equals(s)) { arrayList.remove(s); } else { System.out.println(s + \u0026#34; \u0026#34;); } }*/ System.out.println(arrayList); } } for-each å®é™…å°±æ˜¯éšå¼ä½¿ç”¨ iterator éå†é›†åˆï¼Œä¸Šé¢çš„ä¾‹å­ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œå¹¶åˆ é™¤å¤±è´¥ã€‚ a\nException in thread \u0026ldquo;main\u0026rdquo; java.util.ConcurrentModificationException\nat java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:937)\nat java.base/java.util.ArrayList$Itr.next(ArrayList.java:891)\nat Solution.main(Solution.java:14)\nç„¶è€Œåˆ é™¤ å€’æ•°ç¬¬äºŒä¸ª å…ƒç´ å´ä¸ä¼šæŠ¥é”™ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;c\u0026#34;.equals(cur)) { arrayList.remove(cur); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } /*for (String s : arrayList) { if (\u0026#34;c\u0026#34;.equals(s)) { arrayList.remove(s); } else { System.out.println(s + \u0026#34; \u0026#34;); } }*/ System.out.println(arrayList); } } a\nb\n[a, b, d]\nåˆ†æ é¦–å…ˆå…ˆè§‚å¯Ÿ ArrayList çš„ iterator()ï¼Œçœ‹è¿­ä»£å™¨æ€ä¹ˆæ„é€ ã€‚ ArrayList çš„ çˆ¶ç±» AbstractList ä¸­ 1 2 3 public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } Itr æ˜¯é‡Œé¢çš„å†…éƒ¨ç±» 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 private class Itr implements Iterator\u0026lt;E\u0026gt; { /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() { return cursor != size(); } public E next() { checkForComodification(); try { int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public void remove() { if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet \u0026lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } cursorï¼šä¸‹ä¸€ä¸ªè¦è®¿é—®çš„å…ƒç´ çš„ç´¢å¼• lastRetï¼šä¸Šä¸€ä¸ªè®¿é—®çš„å…ƒç´ çš„ç´¢å¼• expectedModCount æ˜¯æœŸæœ›çš„è¯¥ List è¢«ä¿®æ”¹çš„æ¬¡æ•°ï¼Œåˆå§‹åŒ–ä¸º modCount modCount æ˜¯ AbstractList çš„ä¸€ä¸ªæˆå‘˜å˜é‡ã€‚ The number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results. This field is used by the iterator and list iterator implementation returned by the iterator and listIterator methods. If the value of this field changes unexpectedly, the iterator (or list iterator) will throw a ConcurrentModificationException in response to the next, remove, previous, set or add operations. This provides fail-fast behavior, rather than non-deterministic behavior in the face of concurrent modification during iteration. Use of this field by subclasses is optional. If a subclass wishes to provide fail-fast iterators (and list iterators), then it merely has to increment this field in its add(int, E) and remove(int) methods (and any other methods that it overrides that result in structural modifications to the list). A single call to add(int, E) or remove(int) must add no more than one to this field, or the iterators (and list iterators) will throw bogus ConcurrentModificationExceptions. If an implementation does not wish to provide fail-fast iterators, this field may be ignored.\n1 protected transient int modCount = 0; ç»“æ„ä¿®æ”¹æ˜¯æŒ‡é‚£äº›æ”¹å˜åˆ—è¡¨å¤§å°çš„ä¿®æ”¹ï¼Œæˆ–è€…ä»¥æŸç§æ–¹å¼æ‰°ä¹±åˆ—è¡¨ï¼Œä½¿å¾—æ­£åœ¨è¿›è¡Œçš„è¿­ä»£å¯èƒ½äº§ç”Ÿä¸æ­£ç¡®çš„ç»“æœã€‚ æ­¤å­—æ®µç”±è¿­ä»£å™¨å’Œ listIteratoræ–¹æ³•è¿”å›çš„è¿­ä»£å™¨å’Œåˆ—è¡¨è¿­ä»£å™¨å®ç°ä½¿ç”¨ã€‚å¦‚æœæ­¤å­—æ®µçš„å€¼æ„å¤–æ›´æ”¹ï¼Œè¿­ä»£å™¨ï¼ˆæˆ–åˆ—è¡¨è¿­ä»£å™¨ï¼‰å°†æŠ›å‡º ConcurrentModificationExceptionä»¥å“åº” nextã€removeã€previousã€set æˆ– add æ“ä½œã€‚è¿™æä¾›äº† å¿«é€Ÿå¤±è´¥ çš„è¡Œä¸ºã€‚ æ·±å…¥ ArrayList é‡Œè§‚å¯Ÿ next() 1 2 3 4 5 6 7 8 9 10 11 public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } 1 2 3 4 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } æŠ›å‡ºçš„ ConcurrentModificationException å¼‚å¸¸æ˜¯ checkForComodification() æŠ›å‡ºçš„ã€‚ æ¡ä»¶æ˜¯ï¼šmodCount != expectedModCount æ‰€ä»¥åœ¨ add remove çš„è¿‡ç¨‹ä¸­ modCount ä¼šè‡ªå¢è‡ªå‡ã€‚å¦‚æœç”¨é›†åˆçš„ removeåˆ™ List çš„ modCountå‡å°‘ä¸€ï¼Œè€Œ Iterator çš„ expectedModCountä¸å˜ï¼Œå°±ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚\nè‡³äºä¸ºä»€ä¹ˆå€’æ•°ç¬¬äºŒä¸ªå…ƒç´ åˆ é™¤ä¸ä¼šæŠ¥é”™ï¼Œæˆ‘ä»¬è¦å…ˆäº†è§£ Iterator éå†çš„ç‰¹ç‚¹ã€‚\nwhile + iterator çš„ç»„åˆæ˜¯éœ€è¦å…ˆåˆ¤ç©º hasNext()ï¼Œç„¶åå† next()ï¼Œæœ€åæ‰ remove()ï¼Œå¦åˆ™ä¼šæŠ¥é”™ï¼Œå¯ä»¥è‡ªè¡Œå®éªŒï¼Œè°ƒæ¢ next å’Œ removeã€‚\nå› ä¸ºè¦å…ˆ nextï¼Œå°†æ¸¸æ ‡ è¶Šè¿‡ å½“å‰çš„å…ƒç´ ï¼Œç„¶åå†å†³å®šè¦æ€ä¹ˆæ“ä½œå½“å‰çš„ï¼ˆæ¸¸æ ‡å‰é¢çš„ï¼‰è¿™ä¸ªå…ƒç´ ï¼Œå³æ¸¸æ ‡æ˜¯æ’åœ¨ å½“å‰å…ƒç´  å’Œ ä¸‹ä¸€ä¸ªå…ƒç´  çš„ä¸­é—´ï¼ˆå¯ä»¥è¿™ä¹ˆç†è§£ï¼‰ã€‚\nåˆ é™¤å€’æ•°ç¬¬äºŒä¸ªå…ƒç´ çš„æ—¶å€™ï¼Œcursor æŒ‡å‘ æœ€åä¸€ä¸ªå…ƒç´ ï¼Œè€Œæ­¤æ—¶åˆ æ‰äº†å€’æ•°ç¬¬äºŒä¸ªå…ƒç´ åï¼Œcursor å’Œ size() æ­£å¥½ç›¸ç­‰äº†ï¼Œæ‰€ä»¥ hasNext() è¿”å› falseï¼Œéå†ç»“æŸï¼ŒæˆåŠŸçš„åˆ é™¤äº†å€’æ•°ç¬¬äºŒä¸ªå…ƒç´ ã€‚\nå»ºè®®ç”¨æ³• ä¸€ä¸ªåŸåˆ™æ˜¯ï¼Œå°½é‡åœ¨éå†çš„è¿‡ç¨‹ä¸­ä¸è¦å¯¹åŸé›†åˆè¿›è¡Œå¢åˆ ï¼Œå®¹æ˜“æ”¹å˜åŸç»“æ„ï¼Œå¯ä»¥ç”¨ immutable çš„æ€æƒ³ï¼Œé‡æ–°å°è£…ä¸€ä¸ªé›†åˆã€‚\nè¦ remove() ï¼Œåˆ™è¦åœ¨ iterator() ä¸Šé¢æ¥è¿›è¡Œ remove()ï¼Œå› ä¸º Iterator è¿­ä»£ï¼Œå°±æŠŠæ“ä½œæƒäº¤ç»™äº† Iteratorï¼Œå°±ä¸è¦å†ç”¨åŸé›†åˆè¿›è¡Œæ“ä½œäº†ã€‚\næ­£ç¡®ç”¨æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;a\u0026#34;.equals(cur)) { iterator.remove(); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } System.out.println(arrayList); } } b\nc\nd\n[b, c, d]\nä»¥ä¸Šåˆ†ææ˜¯åŸºäº ArrayListï¼ŒåŸºäºé“¾è¡¨çš„ LinkedList é“ç†å¤§åŒå°å¼‚ï¼Œæ€æƒ³ä¸å˜ï¼Œæµ‹è¯•çš„ç»“æœä¹Ÿæ˜¯ä¸å˜çš„ã€‚\n","date":"2021-03-15T20:10:31+08:00","image":"https://capriwits.com/post/iterator-concurrentmodificationexception-problem-when-remove/java-programming-cover_hu4193375dbb5d85283668ea46b44f9b7a_34987_120x120_fill_box_smart1_3.png","permalink":"https://capriwits.com/post/iterator-concurrentmodificationexception-problem-when-remove/","title":"Iterator remove æ—¶å‡ºç° ConcurrentModificationException"}]