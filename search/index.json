[{"content":" 二叉平衡树 AVL 树节点定义 树高度 平衡因子 树的旋转 右旋 RightRotate 左旋 LeftRotate 先左旋后右旋 先右旋再左旋 AVL 旋转策略 插入节点 递归法 递归法 删除节点 递归法 迭代法 单栈（错误代码） 双栈（可行方案） 单栈（修改版） 查找节点 单元测试 Algorithm 4th 实现源码 Reference 二叉平衡树 AVL 树节点定义 树节点结构：\n节点的值 int 左右子树节点 树的高度（需要计算左右子树相对高度，决定是否平衡） “节点高度”是指从该节点到它的最远叶节点的距离，即所经过的“边”的数量。需要特别注意的是，叶节点的高度为 0，而空节点的高度为 -1 1 2 3 4 5 6 7 8 9 public class TreeNode { int val; TreeNode left, right; int height; public TreeNode(int val) { this.val = val; } } 树高度 定义叶子结点的高度是 0，由于更新高度是取左右子树的高度最大值 + 1，而空节点在叶子结点的下面，所以空节点的高度是 -1 1 2 3 4 5 6 7 8 public int height(TreeNode root) { return root == null ? -1 : root.height; } public void updateHeight(TreeNode root) { if (root == null) return; root.height = Math.max(height(root.left), height(root.right)) + 1; } 平衡因子 节点的平衡因子（balance factor）定义为节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为 0 所以任意一棵 AVL 的平衡因子 $f$ 满足 $-1 \\le f \\le 1$，即左右子树高度相差不会超过 1 1 2 3 4 public int balanceFactor(TreeNode root) { if (root == null) return 0; return height(root.left) - height(root.right); } 树的旋转 右旋 RightRotate 以 child 为原点，向右旋转 内侧子树（右旋，是左子树的右侧子树）移接到旋转的另一侧内侧 即根左侧的右子树，移动到根右侧的左子树 涉及到高度变化的是旧 root 和新根 child，因此需要更新 child 变成新的根节点 1 2 3 4 5 6 7 8 public TreeNode rightRotate(TreeNode root) { TreeNode child = root.left, grandChild = child.right; child.right = root; root.left = grandChild; updateHeight(root); updateHeight(child); return child; } 左旋 LeftRotate 左旋同理，与右旋镜像对称 1 2 3 4 5 6 7 8 public TreeNode leftRotate(TreeNode root) { TreeNode child = root.right, grandChild = child.left; child.left = root; root.right = grandChild; updateHeight(root); updateHeight(child); return child; } 先左旋后右旋 先右旋再左旋 AVL 旋转策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public TreeNode rotate(TreeNode root) { int balanceFactor = balanceFactor(root); // 左偏树 if (balanceFactor \u0026gt; 1) { if (balanceFactor(root.left) \u0026gt;= 0) return rightRotate(root); // LL else { // LR root.left = leftRotate(root.left); return rightRotate(root); } } else if (balanceFactor \u0026lt; -1) { // 右偏树 if (balanceFactor(root.right) \u0026lt;= 0) return leftRotate(root); // RR else { // RL root.right = rightRotate(root.right); return leftRotate(root); } } // 其他情况是平衡树，无需旋转 return root; } 插入节点 递归法 类似 BST 插入，先找位置插入 插入后需要更新节点高度，由于是递归调用，因此在每一层遍历更新一次节点高度即可 插入后旋转当前节点，平衡子树，同样在递归中调用，每一层都会旋转调整 1 2 3 4 5 6 7 8 9 public TreeNode insert(TreeNode root, int val) { if (root == null) return new TreeNode(val); if (val \u0026lt; root.val) root.left = insert(root.left, val); else if (val \u0026gt; root.val) root.right = insert(root.right, val); else return root; // 重复节点，不插入 updateHeight(root); // 插入后更新高度 root = rotate(root); // 旋转操作，使子树平衡 return root; } 递归法 迭代法，向下找到插入位置的过程，将路径保存在栈中，然后自底向上更新高度和旋转 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public TreeNode insert(TreeNode root, int val) { if (root == null) return new TreeNode(val); TreeNode cur = root, pre = null; Deque\u0026lt;TreeNode\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); // 找到插入位置 while (cur != null) { stack.push(cur); pre = cur; if (val == cur.val) return root; // 重复值, 不插入 if (val \u0026lt; cur.val) cur = cur.left; else cur = cur.right; } // 插入节点 if (val \u0026lt; pre.val) pre.left = new TreeNode(val); else pre.right = new TreeNode(val); // 更新高度, 旋转维护 AVL 平衡, 自底向上 while (!stack.isEmpty()) { TreeNode node = stack.pop(); updateHeight(node); node = rotate(node); // 旋转后, 子树根节点可能变化, 更新父节点的子节点指向 if (!stack.isEmpty()) { TreeNode parent = stack.peek(); // 不能 pop, 下一次 while-loop 需要更新高度和旋转 if (node.val \u0026lt; parent.val) parent.left = node; else parent.right = node; } else { root = node; // node 即是 AVL 的根节点 } } return root; } 删除节点 递归法 如下做法，类似 BST，需要在删除节点后，更新 AVL 高度和旋转调整平衡，因此涉及到递归操作 根据 val 递归搜索节点位置，并且需要重新调整 remove 后的节点位置，因为涉及旋转，子树根节点可能发生变化 节点有 0 或 1 个为一种情况，直接取子节点作为新的子树节点删除即可 节点有两个，需要取中序遍历的相邻较大节点（或者相邻较小节点），以下做法是将 root 值替换为 successor 的值，然后将右侧子树的 successor 删除掉，实现删除 root 的需求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public TreeNode remove(TreeNode root, int val) { if (root == null) return null; // 找节点删除 if (val \u0026lt; root.val) root.left = remove(root.left, val); else if (val \u0026gt; root.val) root.right = remove(root.right, val); else { // 子节点有 0 或 1 个 if (root.left == null || root.right == null) { TreeNode child = root.left == null ? root.right : root.left; if (child == null) root = null; // 无子节点，整树删除 else root = child; // 有一个子节点，子节点为新根 } else { // 子节点有 2 个 TreeNode successor = root.right; while (successor.left != null) successor = successor.left; root.right = remove(root.right, successor.val); root.val = successor.val; // 值替换 } } updateHeight(root); // 删除后更新高度 root = rotate(root); // 旋转操作，使子树平衡 return root; } 如果需要引用删除，而不是简答地进行值替换 一样先找后继节点，然后 remove 递归删除掉右子树的后继节点（递归删除会更新高度和旋转），然后直接将 root 左右子树接在后继节点，实现替换，最后需要将新的 root 更新为后继节点（这是必要的，因为递归调用中，当前方法栈的高度和旋转维护是基于 root 的） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public TreeNode remove(TreeNode root, int val) { if (root == null) return null; // 找节点删除 if (val \u0026lt; root.val) root.left = remove(root.left, val); else if (val \u0026gt; root.val) root.right = remove(root.right, val); else { // 子节点有 0 或 1 个 if (root.left == null || root.right == null) { TreeNode child = root.left == null ? root.right : root.left; if (child == null) root = null; // 无子节点，整树删除 else root = child; // 有一个子节点，子节点为新根 } else { // 子节点有 2 个 TreeNode successor = root.right; while (successor.left != null) successor = successor.left; // 找到右子树的最左节点 // 后继节点替换 root; 先将其从右子树删除, 再直接替代 root, 最后需要把 root 更新为后继节点 root.right = remove(root.right, successor.val); successor.left = root.left; successor.right = root.right; root = successor; } } updateHeight(root); // 删除后更新高度 root = rotate(root); // 旋转操作，使子树平衡 return root; } 迭代法 迭代法，用栈记录向下遍历的路径，删除节点后自底向上更新树高度和旋转平衡 与 BST 的删除操作迭代法类似，先让 cur 移动到待删除节点，然后找到中序遍历较大的节点 successor，即右子树的最左节点；将 successor 从右子树移除，再直接替代 cur 的位置，接上 cur 的左右子树到 successor 上即可。 剥离 successor 的过程，一样需要记录到 stack 中，因为这一删除过程也需要更新树高度和旋转平衡 不同于 BST 删除的是，BST 删除可以将 successor.right 交给 successorParent.left，自己成为新的 root，root.left 接管 cur.left；AVL 删除涉及递归地更新每个可能变化的节点的高度和旋转平衡，参考递归法是用 remove(root.right, successor.val) ，可以保证递归过程的所有节点最后都是更新高度和旋转的。 单栈（错误代码） 首先找到同 val 值的待删除节点 cur，过程需要用 stack 记录路径，后续自底向上更新高度和旋转平衡；还需要维护一个前继父节点 pre，删除 cur 后需要修改 pre 的指向 cur 有 0 或 1 个子节点，直接取孩子作为新的子树，接在 pre 上，即 cur 被移除 cur 有两个子节点，这里以中序遍历的较大后续节点替换 cur 为例（选择较小 predecessor 也行） 参考递归法 root.right = remove(root.right, successor.val); 即删除右子树的后继节点 successor，然后 successor 替换 cur（successor 接在 pre 上即可） 这一过程也可以用迭代法来做，找 successor 过程依然用 stack 记录过程 删除 cur 后，需要用栈自底向上更新高度和旋转平衡 由于旋转平衡后，可能子树的根节点会变，因此还需要再从 stack.peek 中找到当前 pop 出节点的父节点，更新该父节点的引用，对应了递归法的 root.left = remove(root.left, val); ，每层递归过后都会 rotate 返回子树的新节点，还需要更新父节点指向。 重点在于迭代过程的 stack 记录的节点不能漏（少更新高度和平衡），同时 stack 压入的节点还需要保证相邻节点为父子关系\n以下代码问题在于：stack 先记录了 [root, cur] 位置，然后又记录了 [cur, successor] ，但更新高度时，由于 cur 已被删除，虽然 pre 的孩子已经改为 successor，但是 cur 已经入栈，在 stack.peek 出的 pre 还是会指向旧的 cur 节点，引发错误\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public TreeNode remove(TreeNode root, int val) { if (root == null) return null; // 找节点删除 TreeNode cur = root, pre = null; Deque\u0026lt;TreeNode\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); while (cur != null) { stack.push(cur); // 记录路径 if (val == cur.val) break; pre = cur; if (val \u0026lt; cur.val) cur = cur.left; else cur = cur.right; } if (cur == null) return root; // 没有找到, 忽略删除 // cur 就是待删除节点 if (cur.left == null || cur.right == null) { // 待删除节点有 0 或 1 个子节点 TreeNode child = cur.left == null ? cur.right : cur.left; // 删除根节点, 不影响子树高度和平衡, 可直接返回 if (pre == null) return child; if (cur == pre.left) pre.left = child; else pre.right = child; } else { // 有两个子节点 TreeNode successor = cur.right, successorParent = cur; while (successor.left != null) { stack.push(successor); // 记录路径 successorParent = successor; successor = successor.left; } // cur 右子树删除 successor 节点 if (successorParent == cur) { // successor 是 cur 的直接右子节点 successorParent.right = successor.right; } else { successorParent.left = successor.right; } // 删除 cur, successor 替换 cur successor.left = cur.left; successor.right = cur.right; // 维护新的 root(cur 的父节点) if (pre == null) root = successor; // 删除根节点 else if (cur == pre.left) pre.left = successor; else pre.right = successor; } // 更新高度, 旋转维护 AVL 平衡, 自底向上 while (!stack.isEmpty()) { TreeNode node = stack.pop(); updateHeight(node); node = rotate(node); // 旋转后, 子树根节点可能变化, 更新父节点的子节点指向 if (!stack.isEmpty()) { TreeNode parent = stack.peek(); // 不能 pop, 下一次 while-loop 需要更新高度和旋转 if (node.val \u0026lt; parent.val) parent.left = node; else parent.right = node; } else { root = node; // node 即是 AVL 的根节点 } } return root; } 双栈（可行方案） 以上错误出在，已被删除的 cur 参与到高度更新中 可以考虑双栈，stackCur 记录 [root, cur) ，stackSucc 记录 (cur, successor] 考虑双栈的目的是：每递归调用一次 remove 就维护一个栈，这里涉及到递归移除 cur 右子树的 successor，所以再加一个栈 几个细节 保证 cur 不能加入到 stackCur 保证 successor 替代 cur 后，加入到 stackCur ，保证 successor 在栈中相邻的直接父节点就是 pre 更新高度需要自底向上，先更新 stackSucc ，再更新 stackCur ；stackSucc 不能更新到 root，而 stackCur 最顶层需要更新 root（有可能删除的是 AVL 根节点） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 public TreeNode remove(TreeNode root, int val) { if (root == null) return null; // 找节点删除 TreeNode cur = root, pre = null; Deque\u0026lt;TreeNode\u0026gt; stackCur = new ArrayDeque\u0026lt;\u0026gt;(); // 记录 Cur 之前的路径 Deque\u0026lt;TreeNode\u0026gt; stackSucc = new ArrayDeque\u0026lt;\u0026gt;(); // 记录 Cur 到 Successor 的路径 while (cur != null) { stackCur.push(cur); // 记录路径 if (val == cur.val) break; pre = cur; if (val \u0026lt; cur.val) cur = cur.left; else cur = cur.right; } if (cur == null) return root; // 没有找到, 忽略删除 stackCur.pop(); // cur 会被删除, 所以不需要再更新 // cur 就是待删除节点 if (cur.left == null || cur.right == null) { // 待删除节点有 0 或 1 个子节点 TreeNode child = cur.left == null ? cur.right : cur.left; // 删除根节点, 不影响子树高度和平衡, 可直接返回 if (pre == null) return child; if (cur == pre.left) pre.left = child; else pre.right = child; } else { // 有两个子节点 TreeNode successor = cur.right, successorParent = cur; while (successor.left != null) { stackSucc.push(successor); // 记录路径 successorParent = successor; successor = successor.left; } // cur 右子树删除 successor 节点 if (successorParent == cur) { // successor 是 cur 的直接右子节点 successorParent.right = successor.right; } else { successorParent.left = successor.right; } // 删除 cur, successor 替换 cur successor.left = cur.left; successor.right = cur.right; stackCur.push(successor); // successor 替换 cur, 加入到 stackCur 中, 其父节点时 pre // 维护新的 root(cur 的父节点) if (pre == null) root = successor; // 删除根节点 else if (cur == pre.left) pre.left = successor; else pre.right = successor; } // 更新高度, 旋转维护 AVL 平衡, 自底向上, 所以从 stackSucc 开始 while (!stackSucc.isEmpty()) { TreeNode node = stackSucc.pop(); updateHeight(node); node = rotate(node); // 旋转后, 子树根节点可能变化, 更新父节点的子节点指向 if (!stackSucc.isEmpty()) { TreeNode parent = stackSucc.peek(); // 不能 pop, 下一次 while-loop 需要更新高度和旋转 if (node.val \u0026lt; parent.val) parent.left = node; else parent.right = node; } } // 然后再更新 stackCur, 区别于 stackSucc, 多了 root 节点的更新, 可能删除的节点是 root while (!stackCur.isEmpty()) { TreeNode node = stackCur.pop(); updateHeight(node); node = rotate(node); // 旋转后, 子树根节点可能变化, 更新父节点的子节点指向 if (!stackCur.isEmpty()) { TreeNode parent = stackCur.peek(); // 不能 pop, 下一次 while-loop 需要更新高度和旋转 if (node.val \u0026lt; parent.val) parent.left = node; else parent.right = node; } else { root = node; // node 即是 AVL 的根节点 } } return root; } 单栈（修改版） 以上开启双栈的目的是 cur 夹在 stack 中间，cur 被删除后破坏 stack 相邻节点是父子关系的逻辑，在维护高度和旋转的时候不正确 可以想到找到 successor 后，可以直接将 stack 中夹在中间的 cur 替换为 successor，即 stack 记录过程： [root, cur] + [cur.right, successor) + replace(stack, cur, successor) cur 只有 0 或 1 个子节点情况 多了一个步骤，如果存在 child，则将 cur 替换为 child；没有 child，应该 pop 出栈顶的 cur cur 有 2 个子节点情况 在 successor 替换 cur 后，需要更新栈状态：cur 替换为 successor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public TreeNode remove(TreeNode root, int val) { if (root == null) return null; // 找节点删除 TreeNode cur = root, pre = null; Deque\u0026lt;TreeNode\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); while (cur != null) { stack.push(cur); // 记录路径 if (val == cur.val) break; pre = cur; if (val \u0026lt; cur.val) cur = cur.left; else cur = cur.right; } if (cur == null) return root; // 没有找到, 忽略删除 // cur 就是待删除节点 if (cur.left == null || cur.right == null) { // 待删除节点有 0 或 1 个子节点 TreeNode child = cur.left == null ? cur.right : cur.left; // 删除根节点, 不影响子树高度和平衡, 可直接返回 if (pre == null) return child; if (cur == pre.left) pre.left = child; else pre.right = child; if (child != null) replaceStack(stack, cur, child); // 将栈中 cur 替换为 child else stack.pop(); // 栈顶 cur 已被删除, 且没有新的子节点入栈 } else { // 有两个子节点 TreeNode successor = cur.right, successorParent = cur; while (successor.left != null) { stack.push(successor); // 记录路径 successorParent = successor; successor = successor.left; } // cur 右子树删除 successor 节点 if (successorParent == cur) { // successor 是 cur 的直接右子节点 successorParent.right = successor.right; } else { successorParent.left = successor.right; } // 删除 cur, successor 替换 cur successor.left = cur.left; successor.right = cur.right; replaceStack(stack, cur, successor); // 将栈中 cur 替换为 successor // 维护新的 root(cur 的父节点) if (pre == null) root = successor; // 删除根节点 else if (cur == pre.left) pre.left = successor; else pre.right = successor; } // 更新高度, 旋转维护 AVL 平衡, 自底向上 while (!stack.isEmpty()) { TreeNode node = stack.pop(); updateHeight(node); node = rotate(node); // 旋转后, 子树根节点可能变化, 更新父节点的子节点指向 if (!stack.isEmpty()) { TreeNode parent = stack.peek(); // 不能 pop, 下一次 while-loop 需要更新高度和旋转 if (node.val \u0026lt; parent.val) parent.left = node; else parent.right = node; } else { root = node; // node 即是 AVL 的根节点 } } return root; } // 将 stack 中 oldNode 替换为 newNode public void replaceStack(Deque\u0026lt;TreeNode\u0026gt; stack, TreeNode oldNode, TreeNode newNode) { Deque\u0026lt;TreeNode\u0026gt; tempStack = new LinkedList\u0026lt;\u0026gt;(); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (node == oldNode) { stack.push(newNode); break; } else { tempStack.push(node); } } // 将临时栈中的元素重新压入原栈 while (!tempStack.isEmpty()) { stack.push(tempStack.pop()); } } 查找节点 同 BST 查找节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * BST 查找 * * @param root 根节点 * @param num 待查找的值 * @return 查找到的节点 */ public TreeNode search(TreeNode root, int num) { TreeNode cur = root; while (cur != null) { if (num == cur.val) break; else if (num \u0026lt; cur.val) cur = cur.left; else cur = cur.right; } return cur; } 单元测试 单元测试 AVL 插入和删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 public class Solution { public static void main(String[] args) { AVLTree avl = new AVLTree(); TreeNode root = null; // 测试插入操作 System.out.println(\u0026#34;Insert Operation:\u0026#34;); int[] insertValues = {30, 20, 40, 10, 25, 35, 50, 5, 15, 27, 26}; for (int val : insertValues) { root = avl.insert(root, val); List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; levels = avl.levelOrderTraversal(root); printLevels(levels); System.out.println(\u0026#34;----------\u0026#34;); } // 测试删除操作 System.out.println(\u0026#34;Remove Operation:\u0026#34;); int[] removeValues = {10, 20, 30, 5, 27}; for (int val : removeValues) { root = avl.remove(root, val); List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; levels = avl.levelOrderTraversal(root); printLevels(levels); System.out.println(\u0026#34;----------\u0026#34;); } } // 打印层序遍历结果 public static void printLevels(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; levels) { for (List\u0026lt;String\u0026gt; level : levels) { System.out.println(level); } } } class TreeNode { int val; TreeNode left, right; int height; public TreeNode(int val) { this.val = val; } } class AVLTree { public int height(TreeNode root) { return root == null ? -1 : root.height; } public void updateHeight(TreeNode root) { if (root == null) return; root.height = Math.max(height(root.left), height(root.right)) + 1; } public int balanceFactor(TreeNode root) { if (root == null) return 0; return height(root.left) - height(root.right); } public TreeNode rightRotate(TreeNode root) { TreeNode child = root.left, grandChild = child.right; child.right = root; root.left = grandChild; updateHeight(root); updateHeight(child); return child; } public TreeNode leftRotate(TreeNode root) { TreeNode child = root.right, grandChild = child.left; child.left = root; root.right = grandChild; updateHeight(root); updateHeight(child); return child; } public TreeNode rotate(TreeNode root) { int balanceFactor = balanceFactor(root); // 左偏树 if (balanceFactor \u0026gt; 1) { if (balanceFactor(root.left) \u0026gt;= 0) return rightRotate(root); // LL else { // LR root.left = leftRotate(root.left); return rightRotate(root); } } else if (balanceFactor \u0026lt; -1) { // 右偏树 if (balanceFactor(root.right) \u0026lt;= 0) return leftRotate(root); // RR else { // RL root.right = rightRotate(root.right); return leftRotate(root); } } // 其他情况是平衡树，无需旋转 return root; } public TreeNode insert(TreeNode root, int val) { if (root == null) return new TreeNode(val); if (val \u0026lt; root.val) root.left = insert(root.left, val); else if (val \u0026gt; root.val) root.right = insert(root.right, val); else return root; // 重复节点，不插入 updateHeight(root); // 插入后更新高度 root = rotate(root); // 旋转操作，使子树平衡 return root; } public TreeNode remove(TreeNode root, int val) { if (root == null) return null; // 找节点删除 if (val \u0026lt; root.val) root.left = remove(root.left, val); else if (val \u0026gt; root.val) root.right = remove(root.right, val); else { // 子节点有 0 或 1 个 if (root.left == null || root.right == null) { TreeNode child = root.left == null ? root.right : root.left; if (child == null) root = null; // 无子节点，整树删除 else root = child; // 有一个子节点，子节点为新根 } else { // 子节点有 2 个 TreeNode successor = root.right; while (successor.left != null) successor = successor.left; // 找到右子树的最左节点 // 后继节点替换 root; 先将其从右子树删除, 再直接替代 root, 最后需要把 root 更新为后继节点 root.right = remove(root.right, successor.val); successor.left = root.left; successor.right = root.right; root = successor; } } updateHeight(root); // 删除后更新高度 root = rotate(root); // 旋转操作，使子树平衡 return root; } // 层序遍历打印树结构 public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; levelOrderTraversal(TreeNode root) { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return result; Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(root); while (!queue.isEmpty()) { int levelSize = queue.size(); List\u0026lt;String\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); boolean isAllNull = true; for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode node = queue.poll(); if (node != null) { level.add(String.valueOf(node.val)); queue.add(node.left); queue.add(node.right); isAllNull = false; } else { level.add(\u0026#34;#\u0026#34;); } } if (!isAllNull) result.add(level); // 只添加包含非空节点的层 } return result; } } 单元测试结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 Insert Operation: [30] ---------- [30] [20, #] ---------- [30] [20, 40] ---------- [30] [20, 40] [10, #, #, #] ---------- [30] [20, 40] [10, 25, #, #] ---------- [30] [20, 40] [10, 25, 35, #] ---------- [30] [20, 40] [10, 25, 35, 50] ---------- [30] [20, 40] [10, 25, 35, 50] [5, #, #, #, #, #, #, #] ---------- [30] [20, 40] [10, 25, 35, 50] [5, 15, #, #, #, #, #, #] ---------- [30] [20, 40] [10, 25, 35, 50] [5, 15, #, 27, #, #, #, #] ---------- [30] [20, 40] [10, 26, 35, 50] [5, 15, 25, 27, #, #, #, #] ---------- Remove Operation: [30] [20, 40] [15, 26, 35, 50] [5, #, 25, 27, #, #, #, #] ---------- [30] [25, 40] [15, 26, 35, 50] [5, #, #, 27, #, #, #, #] ---------- [35] [25, 40] [15, 26, #, 50] [5, #, #, 27, #, #] ---------- [35] [25, 40] [15, 26, #, 50] [#, #, #, 27, #, #] ---------- [35] [25, 40] [15, 26, #, 50] ---------- Algorithm 4th 实现源码 Algorithm 4th AVL 实现源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 /****************************************************************************** * Compilation: javac AVLTreeST.java * Execution: java AVLTreeST \u0026lt; input.txt * Dependencies: StdIn.java StdOut.java * Data files: https://algs4.cs.princeton.edu/33balanced/tinyST.txt * * A symbol table implemented using an AVL tree. * * % more tinyST.txt * S E A R C H E X A M P L E * * % java AVLTreeST \u0026lt; tinyST.txt * A 8 * C 4 * E 12 * H 5 * L 11 * M 9 * P 10 * R 3 * S 0 * X 7 * ******************************************************************************/ package edu.princeton.cs.algs4; import java.util.NoSuchElementException; /** * The {@code AVLTreeST} class represents an ordered symbol table of * generic key-value pairs. It supports the usual \u0026lt;em\u0026gt;put\u0026lt;/em\u0026gt;, \u0026lt;em\u0026gt;get\u0026lt;/em\u0026gt;, * \u0026lt;em\u0026gt;contains\u0026lt;/em\u0026gt;, \u0026lt;em\u0026gt;delete\u0026lt;/em\u0026gt;, \u0026lt;em\u0026gt;size\u0026lt;/em\u0026gt;, and \u0026lt;em\u0026gt;is-empty\u0026lt;/em\u0026gt; * methods. It also provides ordered methods for finding the \u0026lt;em\u0026gt;minimum\u0026lt;/em\u0026gt;, * \u0026lt;em\u0026gt;maximum\u0026lt;/em\u0026gt;, \u0026lt;em\u0026gt;floor\u0026lt;/em\u0026gt;, and \u0026lt;em\u0026gt;ceiling\u0026lt;/em\u0026gt;. It also provides a * \u0026lt;em\u0026gt;keys\u0026lt;/em\u0026gt; method for iterating over all of the keys. A symbol table * implements the \u0026lt;em\u0026gt;associative array\u0026lt;/em\u0026gt; abstraction: when associating a * value with a key that is already in the symbol table, the convention is to * replace the old value with the new value. Unlike {@link java.util.Map}, this * class uses the convention that values cannot be {@code null} * —setting the value associated with a key to {@code null} is * equivalent to deleting the key from the symbol table. * \u0026lt;p\u0026gt; * This symbol table implementation uses internally an * \u0026lt;a href=\u0026#34;https://en.wikipedia.org/wiki/AVL_tree\u0026#34;\u0026gt; AVL tree \u0026lt;/a\u0026gt; (Georgy * Adelson-Velsky and Evgenii Landis\u0026#39; tree) which is a self-balancing BST. * In an AVL tree, the heights of the two child subtrees of any * node differ by at most one; if at any time they differ by more than one, * rebalancing is done to restore this property. * \u0026lt;p\u0026gt; * This implementation requires that the key type implements the * {@code Comparable} interface and calls the {@code compareTo()} and * method to compare two keys. It does not call either {@code equals()} or * {@code hashCode()}. The \u0026lt;em\u0026gt;put\u0026lt;/em\u0026gt;, \u0026lt;em\u0026gt;get\u0026lt;/em\u0026gt;, \u0026lt;em\u0026gt;contains\u0026lt;/em\u0026gt;, * \u0026lt;em\u0026gt;delete\u0026lt;/em\u0026gt;, \u0026lt;em\u0026gt;minimum\u0026lt;/em\u0026gt;, \u0026lt;em\u0026gt;maximum\u0026lt;/em\u0026gt;, \u0026lt;em\u0026gt;ceiling\u0026lt;/em\u0026gt;, and * \u0026lt;em\u0026gt;floor\u0026lt;/em\u0026gt; operations each take logarithmic time in the worst case. The * \u0026lt;em\u0026gt;size\u0026lt;/em\u0026gt;, and \u0026lt;em\u0026gt;is-empty\u0026lt;/em\u0026gt; operations take constant time. * Construction also takes constant time. * * For other implementations of the same API, see {@link ST}, {@link BinarySearchST}, * {@link SequentialSearchST}, {@link BST}, {@link RedBlackBST}, * {@link SeparateChainingHashST}, and {@link LinearProbingHashST}. * * @author Marcelo Silva */ public class AVLTreeST\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;, Value\u0026gt; { /** * The root node. */ private Node root; /** * This class represents an inner node of the AVL tree. */ private class Node { private final Key key; // the key private Value val; // the associated value private int height; // height of the subtree private int size; // number of nodes in subtree private Node left; // left subtree private Node right; // right subtree public Node(Key key, Value val, int height, int size) { this.key = key; this.val = val; this.size = size; this.height = height; } } /** * Initializes an empty symbol table. */ public AVLTreeST() { } /** * Checks if the symbol table is empty. * * @return {@code true} if the symbol table is empty. */ public boolean isEmpty() { return root == null; } /** * Returns the number key-value pairs in the symbol table. * * @return the number key-value pairs in the symbol table */ public int size() { return size(root); } /** * Returns the number of nodes in the subtree. * * @param x the subtree * * @return the number of nodes in the subtree */ private int size(Node x) { if (x == null) return 0; return x.size; } /** * Returns the height of the internal AVL tree. It is assumed that the * height of an empty tree is -1 and the height of a tree with just one node * is 0. * * @return the height of the internal AVL tree */ public int height() { return height(root); } /** * Returns the height of the subtree. * * @param x the subtree * * @return the height of the subtree. */ private int height(Node x) { if (x == null) return -1; return x.height; } /** * Returns the value associated with the given key. * * @param key the key * @return the value associated with the given key if the key is in the * symbol table and {@code null} if the key is not in the * symbol table * @throws IllegalArgumentException if {@code key} is {@code null} */ public Value get(Key key) { if (key == null) throw new IllegalArgumentException(\u0026#34;argument to get() is null\u0026#34;); Node x = get(root, key); if (x == null) return null; return x.val; } /** * Returns value associated with the given key in the subtree or * {@code null} if no such key. * * @param x the subtree * @param key the key * @return value associated with the given key in the subtree or * {@code null} if no such key */ private Node get(Node x, Key key) { if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp \u0026lt; 0) return get(x.left, key); else if (cmp \u0026gt; 0) return get(x.right, key); else return x; } /** * Checks if the symbol table contains the given key. * * @param key the key * @return {@code true} if the symbol table contains {@code key} * and {@code false} otherwise * @throws IllegalArgumentException if {@code key} is {@code null} */ public boolean contains(Key key) { return get(key) != null; } /** * Inserts the specified key-value pair into the symbol table, overwriting * the old value with the new value if the symbol table already contains the * specified key. Deletes the specified key (and its associated value) from * this symbol table if the specified value is {@code null}. * * @param key the key * @param val the value * @throws IllegalArgumentException if {@code key} is {@code null} */ public void put(Key key, Value val) { if (key == null) throw new IllegalArgumentException(\u0026#34;first argument to put() is null\u0026#34;); if (val == null) { delete(key); return; } root = put(root, key, val); assert check(); } /** * Inserts the key-value pair in the subtree. It overrides the old value * with the new value if the symbol table already contains the specified key * and deletes the specified key (and its associated value) from this symbol * table if the specified value is {@code null}. * * @param x the subtree * @param key the key * @param val the value * @return the subtree */ private Node put(Node x, Key key, Value val) { if (x == null) return new Node(key, val, 0, 1); int cmp = key.compareTo(x.key); if (cmp \u0026lt; 0) { x.left = put(x.left, key, val); } else if (cmp \u0026gt; 0) { x.right = put(x.right, key, val); } else { x.val = val; return x; } x.size = 1 + size(x.left) + size(x.right); x.height = 1 + Math.max(height(x.left), height(x.right)); return balance(x); } /** * Restores the AVL tree property of the subtree. * * @param x the subtree * @return the subtree with restored AVL property */ private Node balance(Node x) { if (balanceFactor(x) \u0026lt; -1) { if (balanceFactor(x.right) \u0026gt; 0) { x.right = rotateRight(x.right); } x = rotateLeft(x); } else if (balanceFactor(x) \u0026gt; 1) { if (balanceFactor(x.left) \u0026lt; 0) { x.left = rotateLeft(x.left); } x = rotateRight(x); } return x; } /** * Returns the balance factor of the subtree. The balance factor is defined * as the difference in height of the left subtree and right subtree, in * this order. Therefore, a subtree with a balance factor of -1, 0 or 1 has * the AVL property since the heights of the two child subtrees differ by at * most one. * * @param x the subtree * @return the balance factor of the subtree */ private int balanceFactor(Node x) { return height(x.left) - height(x.right); } /** * Rotates the given subtree to the right. * * @param x the subtree * @return the right rotated subtree */ private Node rotateRight(Node x) { Node y = x.left; x.left = y.right; y.right = x; y.size = x.size; x.size = 1 + size(x.left) + size(x.right); x.height = 1 + Math.max(height(x.left), height(x.right)); y.height = 1 + Math.max(height(y.left), height(y.right)); return y; } /** * Rotates the given subtree to the left. * * @param x the subtree * @return the left rotated subtree */ private Node rotateLeft(Node x) { Node y = x.right; x.right = y.left; y.left = x; y.size = x.size; x.size = 1 + size(x.left) + size(x.right); x.height = 1 + Math.max(height(x.left), height(x.right)); y.height = 1 + Math.max(height(y.left), height(y.right)); return y; } /** * Removes the specified key and its associated value from the symbol table * (if the key is in the symbol table). * * @param key the key * @throws IllegalArgumentException if {@code key} is {@code null} */ public void delete(Key key) { if (key == null) throw new IllegalArgumentException(\u0026#34;argument to delete() is null\u0026#34;); if (!contains(key)) return; root = delete(root, key); assert check(); } /** * Removes the specified key and its associated value from the given * subtree. * * @param x the subtree * @param key the key * @return the updated subtree */ private Node delete(Node x, Key key) { int cmp = key.compareTo(x.key); if (cmp \u0026lt; 0) { x.left = delete(x.left, key); } else if (cmp \u0026gt; 0) { x.right = delete(x.right, key); } else { if (x.left == null) { return x.right; } else if (x.right == null) { return x.left; } else { Node y = x; x = min(y.right); x.right = deleteMin(y.right); x.left = y.left; } } x.size = 1 + size(x.left) + size(x.right); x.height = 1 + Math.max(height(x.left), height(x.right)); return balance(x); } /** * Removes the smallest key and associated value from the symbol table. * * @throws NoSuchElementException if the symbol table is empty */ public void deleteMin() { if (isEmpty()) throw new NoSuchElementException(\u0026#34;called deleteMin() with empty symbol table\u0026#34;); root = deleteMin(root); assert check(); } /** * Removes the smallest key and associated value from the given subtree. * * @param x the subtree * @return the updated subtree */ private Node deleteMin(Node x) { if (x.left == null) return x.right; x.left = deleteMin(x.left); x.size = 1 + size(x.left) + size(x.right); x.height = 1 + Math.max(height(x.left), height(x.right)); return balance(x); } /** * Removes the largest key and associated value from the symbol table. * * @throws NoSuchElementException if the symbol table is empty */ public void deleteMax() { if (isEmpty()) throw new NoSuchElementException(\u0026#34;called deleteMax() with empty symbol table\u0026#34;); root = deleteMax(root); assert check(); } /** * Removes the largest key and associated value from the given subtree. * * @param x the subtree * @return the updated subtree */ private Node deleteMax(Node x) { if (x.right == null) return x.left; x.right = deleteMax(x.right); x.size = 1 + size(x.left) + size(x.right); x.height = 1 + Math.max(height(x.left), height(x.right)); return balance(x); } /** * Returns the smallest key in the symbol table. * * @return the smallest key in the symbol table * @throws NoSuchElementException if the symbol table is empty */ public Key min() { if (isEmpty()) throw new NoSuchElementException(\u0026#34;called min() with empty symbol table\u0026#34;); return min(root).key; } /** * Returns the node with the smallest key in the subtree. * * @param x the subtree * @return the node with the smallest key in the subtree */ private Node min(Node x) { if (x.left == null) return x; return min(x.left); } /** * Returns the largest key in the symbol table. * * @return the largest key in the symbol table * @throws NoSuchElementException if the symbol table is empty */ public Key max() { if (isEmpty()) throw new NoSuchElementException(\u0026#34;called max() with empty symbol table\u0026#34;); return max(root).key; } /** * Returns the node with the largest key in the subtree. * * @param x the subtree * @return the node with the largest key in the subtree */ private Node max(Node x) { if (x.right == null) return x; return max(x.right); } /** * Returns the largest key in the symbol table less than or equal to * {@code key}. * * @param key the key * @return the largest key in the symbol table less than or equal to * {@code key} * @throws NoSuchElementException if the symbol table is empty * @throws IllegalArgumentException if {@code key} is {@code null} */ public Key floor(Key key) { if (key == null) throw new IllegalArgumentException(\u0026#34;argument to floor() is null\u0026#34;); if (isEmpty()) throw new NoSuchElementException(\u0026#34;called floor() with empty symbol table\u0026#34;); Node x = floor(root, key); if (x == null) return null; else return x.key; } /** * Returns the node in the subtree with the largest key less than or equal * to the given key. * * @param x the subtree * @param key the key * @return the node in the subtree with the largest key less than or equal * to the given key */ private Node floor(Node x, Key key) { if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0) return x; if (cmp \u0026lt; 0) return floor(x.left, key); Node y = floor(x.right, key); if (y != null) return y; else return x; } /** * Returns the smallest key in the symbol table greater than or equal to * {@code key}. * * @param key the key * @return the smallest key in the symbol table greater than or equal to * {@code key} * @throws NoSuchElementException if the symbol table is empty * @throws IllegalArgumentException if {@code key} is {@code null} */ public Key ceiling(Key key) { if (key == null) throw new IllegalArgumentException(\u0026#34;argument to ceiling() is null\u0026#34;); if (isEmpty()) throw new NoSuchElementException(\u0026#34;called ceiling() with empty symbol table\u0026#34;); Node x = ceiling(root, key); if (x == null) return null; else return x.key; } /** * Returns the node in the subtree with the smallest key greater than or * equal to the given key. * * @param x the subtree * @param key the key * @return the node in the subtree with the smallest key greater than or * equal to the given key */ private Node ceiling(Node x, Key key) { if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0) return x; if (cmp \u0026gt; 0) return ceiling(x.right, key); Node y = ceiling(x.left, key); if (y != null) return y; else return x; } /** * Returns the kth smallest key in the symbol table. * * @param k the order statistic * @return the kth smallest key in the symbol table * @throws IllegalArgumentException unless {@code k} is between 0 and * {@code size() -1 } */ public Key select(int k) { if (k \u0026lt; 0 || k \u0026gt;= size()) throw new IllegalArgumentException(\u0026#34;k is not in range 0-\u0026#34; + (size() - 1)); Node x = select(root, k); return x.key; } /** * Returns the node with key the kth smallest key in the subtree. * * @param x the subtree * @param k the kth smallest key in the subtree * @return the node with key the kth smallest key in the subtree */ private Node select(Node x, int k) { if (x == null) return null; int t = size(x.left); if (t \u0026gt; k) return select(x.left, k); else if (t \u0026lt; k) return select(x.right, k - t - 1); else return x; } /** * Returns the number of keys in the symbol table strictly less than * {@code key}. * * @param key the key * @return the number of keys in the symbol table strictly less than * {@code key} * @throws IllegalArgumentException if {@code key} is {@code null} */ public int rank(Key key) { if (key == null) throw new IllegalArgumentException(\u0026#34;argument to rank() is null\u0026#34;); return rank(key, root); } /** * Returns the number of keys in the subtree less than key. * * @param key the key * @param x the subtree * @return the number of keys in the subtree less than key */ private int rank(Key key, Node x) { if (x == null) return 0; int cmp = key.compareTo(x.key); if (cmp \u0026lt; 0) return rank(key, x.left); else if (cmp \u0026gt; 0) return 1 + size(x.left) + rank(key, x.right); else return size(x.left); } /** * Returns all keys in the symbol table. * * @return all keys in the symbol table */ public Iterable\u0026lt;Key\u0026gt; keys() { return keysInOrder(); } /** * Returns all keys in the symbol table following an in-order traversal. * * @return all keys in the symbol table following an in-order traversal */ public Iterable\u0026lt;Key\u0026gt; keysInOrder() { Queue\u0026lt;Key\u0026gt; queue = new Queue\u0026lt;Key\u0026gt;(); keysInOrder(root, queue); return queue; } /** * Adds the keys in the subtree to queue following an in-order traversal. * * @param x the subtree * @param queue the queue */ private void keysInOrder(Node x, Queue\u0026lt;Key\u0026gt; queue) { if (x == null) return; keysInOrder(x.left, queue); queue.enqueue(x.key); keysInOrder(x.right, queue); } /** * Returns all keys in the symbol table following a level-order traversal. * * @return all keys in the symbol table following a level-order traversal. */ public Iterable\u0026lt;Key\u0026gt; keysLevelOrder() { Queue\u0026lt;Key\u0026gt; queue = new Queue\u0026lt;Key\u0026gt;(); if (!isEmpty()) { Queue\u0026lt;Node\u0026gt; queue2 = new Queue\u0026lt;Node\u0026gt;(); queue2.enqueue(root); while (!queue2.isEmpty()) { Node x = queue2.dequeue(); queue.enqueue(x.key); if (x.left != null) { queue2.enqueue(x.left); } if (x.right != null) { queue2.enqueue(x.right); } } } return queue; } /** * Returns all keys in the symbol table in the given range. * * @param lo the lowest key * @param hi the highest key * @return all keys in the symbol table between {@code lo} (inclusive) * and {@code hi} (exclusive) * @throws IllegalArgumentException if either {@code lo} or {@code hi} * is {@code null} */ public Iterable\u0026lt;Key\u0026gt; keys(Key lo, Key hi) { if (lo == null) throw new IllegalArgumentException(\u0026#34;first argument to keys() is null\u0026#34;); if (hi == null) throw new IllegalArgumentException(\u0026#34;second argument to keys() is null\u0026#34;); Queue\u0026lt;Key\u0026gt; queue = new Queue\u0026lt;Key\u0026gt;(); keys(root, queue, lo, hi); return queue; } /** * Adds the keys between {@code lo} and {@code hi} in the subtree * to the {@code queue}. * * @param x the subtree * @param queue the queue * @param lo the lowest key * @param hi the highest key */ private void keys(Node x, Queue\u0026lt;Key\u0026gt; queue, Key lo, Key hi) { if (x == null) return; int cmplo = lo.compareTo(x.key); int cmphi = hi.compareTo(x.key); if (cmplo \u0026lt; 0) keys(x.left, queue, lo, hi); if (cmplo \u0026lt;= 0 \u0026amp;\u0026amp; cmphi \u0026gt;= 0) queue.enqueue(x.key); if (cmphi \u0026gt; 0) keys(x.right, queue, lo, hi); } /** * Returns the number of keys in the symbol table in the given range. * * @param lo minimum endpoint * @param hi maximum endpoint * @return the number of keys in the symbol table between {@code lo} * (inclusive) and {@code hi} (exclusive) * @throws IllegalArgumentException if either {@code lo} or {@code hi} * is {@code null} */ public int size(Key lo, Key hi) { if (lo == null) throw new IllegalArgumentException(\u0026#34;first argument to size() is null\u0026#34;); if (hi == null) throw new IllegalArgumentException(\u0026#34;second argument to size() is null\u0026#34;); if (lo.compareTo(hi) \u0026gt; 0) return 0; if (contains(hi)) return rank(hi) - rank(lo) + 1; else return rank(hi) - rank(lo); } /** * Checks if the AVL tree invariants are fine. * * @return {@code true} if the AVL tree invariants are fine */ private boolean check() { if (!isBST()) StdOut.println(\u0026#34;Symmetric order not consistent\u0026#34;); if (!isAVL()) StdOut.println(\u0026#34;AVL property not consistent\u0026#34;); if (!isSizeConsistent()) StdOut.println(\u0026#34;Subtree counts not consistent\u0026#34;); if (!isRankConsistent()) StdOut.println(\u0026#34;Ranks not consistent\u0026#34;); return isBST() \u0026amp;\u0026amp; isAVL() \u0026amp;\u0026amp; isSizeConsistent() \u0026amp;\u0026amp; isRankConsistent(); } /** * Checks if AVL property is consistent. * * @return {@code true} if AVL property is consistent. */ private boolean isAVL() { return isAVL(root); } /** * Checks if AVL property is consistent in the subtree. * * @param x the subtree * @return {@code true} if AVL property is consistent in the subtree */ private boolean isAVL(Node x) { if (x == null) return true; int bf = balanceFactor(x); if (bf \u0026gt; 1 || bf \u0026lt; -1) return false; return isAVL(x.left) \u0026amp;\u0026amp; isAVL(x.right); } /** * Checks if the symmetric order is consistent. * * @return {@code true} if the symmetric order is consistent */ private boolean isBST() { return isBST(root, null, null); } /** * Checks if the tree rooted at x is a BST with all keys strictly between * min and max (if min or max is null, treat as empty constraint) Credit: * Bob Dondero\u0026#39;s elegant solution * * @param x the subtree * @param min the minimum key in subtree * @param max the maximum key in subtree * @return {@code true} if if the symmetric order is consistent */ private boolean isBST(Node x, Key min, Key max) { if (x == null) return true; if (min != null \u0026amp;\u0026amp; x.key.compareTo(min) \u0026lt;= 0) return false; if (max != null \u0026amp;\u0026amp; x.key.compareTo(max) \u0026gt;= 0) return false; return isBST(x.left, min, x.key) \u0026amp;\u0026amp; isBST(x.right, x.key, max); } /** * Checks if size is consistent. * * @return {@code true} if size is consistent */ private boolean isSizeConsistent() { return isSizeConsistent(root); } /** * Checks if the size of the subtree is consistent. * * @return {@code true} if the size of the subtree is consistent */ private boolean isSizeConsistent(Node x) { if (x == null) return true; if (x.size != size(x.left) + size(x.right) + 1) return false; return isSizeConsistent(x.left) \u0026amp;\u0026amp; isSizeConsistent(x.right); } /** * Checks if rank is consistent. * * @return {@code true} if rank is consistent */ private boolean isRankConsistent() { for (int i = 0; i \u0026lt; size(); i++) if (i != rank(select(i))) return false; for (Key key : keys()) if (key.compareTo(select(rank(key))) != 0) return false; return true; } /** * Unit tests the {@code AVLTreeST} data type. * * @param args the command-line arguments */ public static void main(String[] args) { AVLTreeST\u0026lt;String, Integer\u0026gt; st = new AVLTreeST\u0026lt;String, Integer\u0026gt;(); for (int i = 0; !StdIn.isEmpty(); i++) { String key = StdIn.readString(); st.put(key, i); } for (String s : st.keys()) StdOut.println(s + \u0026#34; \u0026#34; + st.get(s)); StdOut.println(); } } /****************************************************************************** * Copyright 2002-2022, Robert Sedgewick and Kevin Wayne. * * This file is part of algs4.jar, which accompanies the textbook * * Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne, * Addison-Wesley Professional, 2011, ISBN 0-321-57351-X. * http://algs4.cs.princeton.edu * * * algs4.jar is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * algs4.jar is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with algs4.jar. If not, see http://www.gnu.org/licenses. ******************************************************************************/ Reference algo4 的实现源码 https://www.hello-algo.com/chapter_tree/avl_tree ","date":"2024-11-23T19:10:16+08:00","image":"https://capriwits.com/post/avl-tree-source-code-analysis/Tree-icon_hu14458731151792794833.png","permalink":"https://capriwits.com/post/avl-tree-source-code-analysis/","title":"二叉平衡树源码解析"},{"content":" 红黑树 RBT 1. 红黑树介绍 2. 红黑树的定义和性质 3. 红黑树插入 3.1 插在根节点上 3.2 插入节点的父节点是黑色 3.3 插入节点的父节点是红色 3.3.1 叔叔节点是红色 3.3.2 叔叔节点是黑色，且当前节点是其父节点的右孩子 3.3.3 叔叔节点是黑色，且当前节点是其父节点的左孩子 4. 红黑树删除 4.1 删除 ”红“ + ”黑“ 节点 4.2 删除根节点 4.3 删除 “黑” + “黑” 节点 4.3.1 兄弟节点为红色 4.3.2 兄弟节点为黑色，兄弟节点的两个孩子都是黑色 4.3.3 兄弟节点为黑色，兄弟节点左孩子红色，右孩子黑色 4.3.4 兄弟节点黑色，兄弟节点右孩子红色，左孩子任意颜色 删除操作总结 红黑树源码 一、红黑树节点定义 二、红黑树定义 三、红黑树搜索 四、左右旋转 五、红黑树插入 六、红黑树删除 七、测试代码 删除操作补充说明 双黑 null 节点无法平衡问题 解决双黑 null 节点平衡问题 JDK TreeMap 实现删除操作 Reference 红黑树 RBT 1. 红黑树介绍 红黑树（Red-Black Tree）是一种自平衡的二叉查找树，它保证在最坏的情况下，基本动态集合操作的时间复杂度为 $O(\\log n)$ 。红黑树通过对节点着色，并在插入或删除节点时进行必要的调整，使树的高度始终保持在 $O(\\log n)$ 以内，从而保证了高效的查找、插入和删除操作。\n红黑树的广泛的应用\nJDK 1.8 开始，HashMap 也引入了红黑树：当冲突的链表长度超过 8 时，自动转为红黑树 Java 中，TreeMap、TreeSet 都使用红黑树作为底层数据结构 Linux 底层的 完全公平调度器 (CFS) 进程调度算法中，vruntime 使用红黑树进行存储。 多路复用技术的 Epoll，其核心结构是红黑树 + 双向链表。 2. 红黑树的定义和性质 红黑树的每个节点都包含一个颜色属性，颜色可以是红色或黑色。红黑树的定义遵循以下五个定义：\n每个节点要么是红色，要么是黑色。 根节点必须是黑色。 叶子节点都是黑色的空节点（NIL），即每个叶子节点都是一个特殊的黑色节点，没有存储实际数据。 如果一个节点是红色的，则它的两个子节点都必须是黑色的。（不能有两个连续的红色节点） 对每个节点，从该节点到 NIL 节点的所有路径上都包含相同数量的黑色节点。 这些性质确保了红黑树的高度始终保持对数增长，从而使查找、插入和删除操作的时间复杂度为 $O(\\log n)$。\n性质：\n从根到叶子的最长的可能路径不多于最短的可能路径的两倍长 最短路径为全黑节点；最长为红黑相间，黑色首尾； 最短路径 k 个黑节点，而最长路径是 2k - 1 3. 红黑树插入 3.1 插在根节点上 直接把该节点染黑（作为根节点\n3.2 插入节点的父节点是黑色 什么都不做（节点为红色\n3.3 插入节点的父节点是红色 3.3.1 叔叔节点是红色 四步做完后，需要从祖父节点继续向上递归\n父节点染黑 叔叔节点染黑 祖父节点染红 祖父节点设为当前节点（红色节点，即之后对当前节点进行操作，递归向上做一样的判断，直到叔叔节点不是红色 3.3.2 叔叔节点是黑色，且当前节点是其父节点的右孩子 该情况无法直接处理，需要左旋后，跳转至 3.3.3\n将父节点作为新的当前节点 以新的当前节点为支点左旋 3.3.3 叔叔节点是黑色，且当前节点是其父节点的左孩子 父节点染黑 祖父节点染红 以祖父节点为支点右旋 4. 红黑树删除 4.1 删除 ”红“ + ”黑“ 节点 待删除节点有一红一黑两个子节点（NIL 为黑色也包括在内）\n直接将红色的子节点染黑即可\n4.2 删除根节点 根节点必然为黑色\n直接将根节点染为黑即可\n4.3 删除 “黑” + “黑” 节点 4.3.1 兄弟节点为红色 有兄弟节点，说明当前节点不是根节点，前面讨论过根节点被删除情况，后面同理。\n兄弟节点染黑 父节点染红 父节点左旋 左旋后，重新设置兄弟节点为当前节点 4.3.2 兄弟节点为黑色，兄弟节点的两个孩子都是黑色 兄弟节点染红 将父节点设为新的当前节点 4.3.3 兄弟节点为黑色，兄弟节点左孩子红色，右孩子黑色 兄弟节点左孩子染黑 兄弟节点染红 兄弟节点右旋 右旋后，更新旋转后的 N 的兄弟节点，即从 S 变成 C 4.3.4 兄弟节点黑色，兄弟节点右孩子红色，左孩子任意颜色 父节点颜色赋值给兄弟节点 父节点染黑 兄弟节点右孩子染黑 父节点左旋 达到平衡，当前节点设为红黑树根节点即可，不再循环，已平衡 删除操作总结 4.3.1 只会执行一次，变成 2/3/4 三种情况\n4.3.2 每执行一次，都会向上递归，最多执行 $log(n)$ 次，递归过程可能再遇到情况一，所以 4.3.1 也是最多 $log(n)$ 次\n4.3.3 执行，会变成情况四；情况四 只会执行一次\n红黑树源码 一、红黑树节点定义 RBT 是个二叉树，同时还需要有颜色，颜色只有红黑两种情况，因此简单使用布尔值表示；\n额外维护父节点 parent，因为插入删除需要找到兄弟或叔叔节点，需要向上遍历；\n默认插入节点就是红色，原因在于：红黑树性质 5 节点到子孙节点所有路径包含相同数量黑节点，因此插入红色节点，就直接满足性质 5\n1 2 3 4 5 6 7 8 9 public class Node { int val; Node left, right, parent; boolean red; // 是否为红色节点, 默认为红色(false) public Node(int val) { this.val = val; } } 二、红黑树定义 1 2 3 4 5 6 7 public class RedBlackTree { // 节点颜色 public static final boolean RED = false; public static final boolean BLACK = true; public Node root; } 三、红黑树搜索 就是普通二叉树的搜索\n1 2 3 4 5 6 7 8 9 public Node search(int val) { Node x = this.root; while (x != null) { if (val == x.val) return x; if (val \u0026lt; x.val) x = x.left; else x = x.right; } return null; } 四、左右旋转 该版本的左右旋转是带 parent 节点更新的，需要注意顺序\n定义 x 是相对于 y 的左侧，例如左旋，则当前节点为 x，右旋则当前节点是 y\n以左旋为例，整体从下到上更新，这样不会丢失指针。\n先改 ly.parent = x 然后将 y 转上去，即修改 px 的孩子，如果 px 为空，该树根节点就是 y；同时修改 y.parent = px 最后更新 y 的孩子，y.left = x, x.parent = y； 3 不能在 2 之前，是因为需要通过 x.parent 找到老的 px，否则 x.parent 改为 y 后，就找不到 px 了\n右旋就是左旋的镜像操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 左旋 public void leftRotate(Node x) { Node y = x.right; x.right = y.left; if (y.left != null) y.left.parent = x; y.parent = x.parent; if (x.parent == null) this.root = y; else if (x == x.parent.left) x.parent.left = y; else x.parent.right = y; y.left = x; x.parent = y; } // 右旋 public void rightRotate(Node y) { Node x = y.left; y.left = x.right; if (x.right != null) x.right.parent = y; x.parent = y.parent; if (y.parent == null) this.root = x; else if (y == y.parent.left) y.parent.left = x; else y.parent.right = x; x.right = y; y.parent = x; } 五、红黑树插入 红黑树插入源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // 插入节点 public void insert(int val) { Node z = new Node(val); // 新节点, 默认红色 z.red = RED; Node y = null, x = this.root; // y 为 z 父节点(起始为空), x 为当前节点, 遍历从 x 根节点开始 while (x != null) { y = x; if (z.val \u0026lt; x.val) x = x.left; else x = x.right; } // x 位置为 z 待插入位置, y 是其父节点 z.parent = y; if (y == null) this.root = z; // z 插入为根节点 else if (z.val \u0026lt; y.val) y.left = z; else y.right = z; // 插入后的调整 insertFixUp(z); } // 插入后调整 public void insertFixUp(Node z) { // 插入节点的父节点为红色, 需要调整(父节点为黑色什么都不做) while (z.parent != null \u0026amp;\u0026amp; z.parent.red == RED) { // z 父节点是祖父节点的左孩子 if (z.parent == z.parent.parent.left) { Node uncle = z.parent.parent.right; // 1. 叔叔节点红色 if (uncle != null \u0026amp;\u0026amp; uncle.red == RED) { z.parent.red = BLACK; // 父节点染黑 uncle.red = BLACK; // 叔叔节点染黑 z.parent.parent.red = RED; // 祖父节点染红 z = z.parent.parent; // 祖父节点作为新节点继续调整 } else { // 2. 叔叔节点黑色 if (z == z.parent.right) { // 2.1 z 是右孩子, 需要左旋到一条直线, 在 2.2 继续处理 z = z.parent; // 对父节点左旋 leftRotate(z); } // 2.2 叔叔节点黑色, z 是左孩子 z.parent.red = BLACK; // 父节点染黑 z.parent.parent.red = RED; // 祖父节点染红 rightRotate(z.parent.parent);// 祖父节点右旋 } } else { // z 父节点是祖父节点的右孩子(右侧即左侧的镜像操作) Node uncle = z.parent.parent.left; if (uncle != null \u0026amp;\u0026amp; uncle.red == RED) { z.parent.red = BLACK; // 父节点染黑 uncle.red = BLACK; // 叔叔节点染黑 z.parent.parent.red = RED; // 祖父节点染红 z = z.parent.parent; // 祖父节点作为新节点继续调整 } else { if (z == z.parent.left) { z = z.parent; // 对父节点右旋 rightRotate(z); } z.parent.red = BLACK; // 父节点染黑 z.parent.parent.red = RED; // 祖父节点染红 leftRotate(z.parent.parent);// 祖父节点左旋 } } } this.root.red = BLACK; // 需要保证根节点为黑色(z 插在根节点上, 需染黑) } 六、红黑树删除 先创建一些辅助方法 transplant，可以替换节点，主要用于 delete 节点时，将后继节点替换目标节点 successor，可以找到节点的中序遍历较大节点值，即 successor(node) getColor，获取节点颜色，多封装一层 NIL 节点判定为黑色 setColor，设置节点颜色，判空，防止空指针 辅助方法源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 替换节点, v 替换 u, 只替换父索引, 不替换子索引 public void transplant(Node u, Node v) { if (u.parent == null) this.root = v; else if (u == u.parent.left) u.parent.left = v; else u.parent.right = v; if (v != null) v.parent = u.parent; } // 寻找子树的最小节点 public Node successor(Node node) { node = node.right; while (node.left != null) { node = node.left; } return node; } // 获取节点的颜色, 若节点为 null 则默认为黑色 private boolean getColor(Node node) { return node == null ? BLACK : node.red; } // 设置节点的颜色 public void setColor(Node node, boolean color) { if (node != null) node.red = color; } 删除后的平衡调整，deleteFixup 方法，入参除了待调整节点 x，还有其父节点 parent，该 parent 存在意义在后面解释\n红黑树删除操作源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 // 删除节点 public Node delete(int val) { Node node = search(val); // 待删除节点 if (node == null) return null; // 待删除节点不存在 Node y = node, x, parent; // y 替换 node 节点, x 记录可能影响平衡的子树, parent 是 node 直接后续节点替换后 x 的父节点 boolean originalColor = y.red; // y 原始颜色 if (node.left == null) { x = node.right; parent = node.parent; transplant(node, node.right); // 右孩子替换 node } else if (node.right == null) { x = node.left; parent = node.parent; transplant(node, node.left); // 左孩子替换 node } else { // 找 node 直接后续节点, 替换 node 为 y(颜色与 node 同色) y = minimum(node); originalColor = y.red; x = y.right; // y 会从右子树移除, 受影响平衡的是 y 的右子树 if (y.parent == node) { // y 是 node 的直接右孩子 parent = y; // 此时 x 可能是 null, 但 x 的父节点就是替换 node 的 y } else { // y 不是 node 的直接右孩子, y 右孩子替换 y parent = y.parent; transplant(y, y.right); y.right = node.right; y.right.parent = y; } transplant(node, y); // y 替换 node y.left = node.left; y.left.parent = y; y.red = node.red; } node.left = node.right = node.parent = null; // 清空 node 引用 if (originalColor == BLACK) // y 从右子树移除到 node, 原来的 y 是黑色则需要调整(红色不影响性质) deleteFixup(x, parent); return node; } /** * 删除后, 从 x 向上修复 * * @param x 修复起点, 可能为 null * @param parent x 的父节点 */ public void deleteFixup(Node x, Node parent) { while (x != root \u0026amp;\u0026amp; getColor(x) == BLACK) { if (x == parent.left) { // x 是左孩子 Node w = parent.right; // w 是 x 的兄弟节点 // 情况1：x 的兄弟节点 w 是红色 if (getColor(w) == RED) { setColor(w, BLACK); // 将 w 变成黑色 setColor(parent, RED); // 将 x 的父节点变成红色 leftRotate(parent); // 对 x 的父节点左旋 w = parent.right; // 旋转后，更新兄弟节点 w } // 情况2：x 的兄弟节点 w 是黑色，且 w 的两个子节点都是黑色 if (getColor(w.left) == BLACK \u0026amp;\u0026amp; getColor(w.right) == BLACK) { setColor(w, RED); // 将 w 变成红色 x = parent; // 继续从父节点向上修复 parent = x.parent; // 更新 parent } else { // 情况3：w 是黑色，且 w 的右孩子是黑色，左孩子是红色 if (getColor(w.right) == BLACK) { // 上面判断过都为黑色, 只要右孩子是黑色, 左孩子就是红色 setColor(w.left, BLACK); // 将 w 的左孩子变成黑色 setColor(w, RED); // 将 w 变成红色 rightRotate(w); // 对 w 右旋 w = parent.right; // 旋转后，更新兄弟节点 w } // 情况4 可能由情况3 转化而来 // 情况4：w 是黑色，且 w 的右孩子是红色 setColor(w, getColor(parent)); // 将 w 设为父节点的颜色 setColor(parent, BLACK); // 将父节点设为黑色 setColor(w.right, BLACK); // 将 w 的右孩子设为黑色 leftRotate(parent); // 对 x 的父节点左旋 x = root; // 修复完成，将 x 设为根节点 } } else { // 如果 x 是右孩子，和左孩子的操作对称，交换左右操作即可 Node w = parent.left; // 情况1：x 的兄弟节点 w 是红色 if (getColor(w) == RED) { setColor(w, BLACK); setColor(parent, RED); rightRotate(parent); w = parent.left; } // 情况2：x 的兄弟节点 w 是黑色，且 w 的两个子节点都是黑色 if (getColor(w.left) == BLACK \u0026amp;\u0026amp; getColor(w.right) == BLACK) { setColor(w, RED); x = parent; parent = x.parent; } else { // 情况3：w 是黑色，且 w 的左孩子是黑色，右孩子是红色 if (getColor(w.left) == BLACK) { setColor(w.right, BLACK); setColor(w, RED); leftRotate(w); w = parent.left; } // 情况4：w 是黑色，且 w 的左孩子是红色 setColor(w, getColor(parent)); setColor(parent, BLACK); setColor(w.left, BLACK); rightRotate(parent); x = root; } } } setColor(x, BLACK); // 将最终的 x 设为黑色 } 七、测试代码 验证红黑树是否符合性质 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 public boolean verifyRBTProperties() { return verifyProperty1(root) \u0026amp;\u0026amp; verifyProperty2(root) \u0026amp;\u0026amp; verifyProperty4(root) \u0026amp;\u0026amp; verifyProperty5(root) \u0026amp;\u0026amp; verifyProperty6(root); } // 红黑树的性质1：每个节点是红色或黑色 private boolean verifyProperty1(Node node) { if (node == null) return true; // null 节点视为黑色 return (node.red || !node.red) \u0026amp;\u0026amp; verifyProperty1(node.left) \u0026amp;\u0026amp; verifyProperty1(node.right); } // 红黑树的性质2：根节点是黑色 private boolean verifyProperty2(Node root) { return root == null || root.red == BLACK; } // 红黑树的性质3：每个叶子节点都是黑色的空节点 null(不用验证) // 红黑树的性质4：每个红色节点的两个子节点都是黑色 private boolean verifyProperty4(Node node) { if (node == null) return true; if (node.red == RED) { if (node.left != null \u0026amp;\u0026amp; node.left.red == RED) return false; if (node.right != null \u0026amp;\u0026amp; node.right.red == RED) return false; } return verifyProperty4(node.left) \u0026amp;\u0026amp; verifyProperty4(node.right); } // 红黑树的性质5：从任一节点到其每个叶子节点的路径都包含相同数目的黑色节点 private boolean verifyProperty5(Node node) { return blackHeight(node) != -1; } // 验证是否为二叉搜索树, 中序遍历结果递增 public boolean verifyProperty6(Node root) { List\u0026lt;Integer\u0026gt; values = new ArrayList\u0026lt;\u0026gt;(); inOrderTraversal(root, values); for (int i = 1; i \u0026lt; values.size(); i++) { if (values.get(i) \u0026lt; values.get(i - 1)) { System.out.println(\u0026#34;Inorder traversal is not increasing: \u0026#34; + values); return false; } } return true; } // 中序遍历，将节点值添加到列表中 private void inOrderTraversal(Node node, List\u0026lt;Integer\u0026gt; values) { if (node == null) { return; } inOrderTraversal(node.left, values); values.add(node.val); inOrderTraversal(node.right, values); } // 计算黑高，如果黑高不一致则返回-1，代表红黑树不合法 private int blackHeight(Node node) { if (node == null) return 1; // null 节点作为黑节点 int leftBlackHeight = blackHeight(node.left); int rightBlackHeight = blackHeight(node.right); if (leftBlackHeight == -1 || rightBlackHeight == -1 || leftBlackHeight != rightBlackHeight) return -1; return leftBlackHeight + (node.red == RED ? 0 : 1); // 红节点不计入黑高 } 打印红黑树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public void printTree(Node root) { if (root == null) return; LinkedList\u0026lt;Node\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(root); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { Node n = queue.poll(); String pos = n.parent == null ? \u0026#34;\u0026#34; : (n == n.parent.left ? \u0026#34; LE\u0026#34; : \u0026#34; RI\u0026#34;); String pstr = n.parent == null ? \u0026#34;\u0026#34; : n.parent.val + \u0026#34;\u0026#34;; String cstr = n.red == RED ? \u0026#34;R\u0026#34; : \u0026#34;B\u0026#34;; cstr = n.parent == null ? cstr : cstr + \u0026#34; \u0026#34;; System.out.print(n.val + \u0026#34;(\u0026#34; + (cstr) + pstr + (pos) + \u0026#34;)\u0026#34; + \u0026#34;\\t\u0026#34;); if (n.left != null) queue.add(n.left); if (n.right != null) queue.add(n.right); } System.out.println(); } } 主函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class Solution { public static void main(String[] args) { /** * 红黑树插入验证 */ RedBlackTree tree = new RedBlackTree(); int[] valuesToInsert = getRamdomIntArray(100); System.out.println(\u0026#34;插入操作：\u0026#34;); for (int value : valuesToInsert) { tree.insert(value); System.out.println(\u0026#34;插入 \u0026#34; + value + \u0026#34; 后的树结构：\u0026#34;); tree.printTree(tree.root); System.out.println(\u0026#34;验证插入后的树结构是否满足红黑树性质：\u0026#34; + tree.verifyRBTProperties()); System.out.println(\u0026#34;\\n-------------------------\u0026#34;); } /** * 红黑树删除验证 */ RedBlackTree tree2 = new RedBlackTree(); for (int value : valuesToInsert) { tree2.insert(value); } System.out.println(\u0026#34;删除操作：\u0026#34;); int[] valuesToDelete = getRamdomIntArray(50); for (int value : valuesToDelete) { tree2.delete(value); System.out.println(\u0026#34;删除 \u0026#34; + value + \u0026#34; 后的树结构：\u0026#34;); tree2.printTree(tree2.root); System.out.println(\u0026#34;验证删除后的树结构是否满足红黑树性质：\u0026#34; + tree2.verifyRBTProperties()); System.out.println(\u0026#34;\\n-------------------------\u0026#34;); } } // 生成随机指定长度随机 int 数组 private static int[] getRamdomIntArray(int size) { Random random = new Random(); int[] arr = new int[size]; for (int i = 0; i \u0026lt; size; i++) { arr[i] = random.nextInt(1000) + 1; } System.out.print(\u0026#34;arr: {\u0026#34;); for (int i = 0; i \u0026lt; size; i++) { System.out.print(arr[i]); if (i \u0026lt; size - 1) System.out.print(\u0026#34;, \u0026#34;); } System.out.println(\u0026#34;}\u0026#34;); return arr; } } 删除操作补充说明 双黑 null 节点无法平衡问题 下面删除操作，在左右孩子都不空的条件下，后继节点 y 会替换 node，而 y 的右孩子会替换 y；\n如果 y 是 node 的直接右孩子，且 y 的右孩子是 null，在删除后的调整后，deleteFixup 的入参 x 是 null，一方面会影响到 x 找到兄弟节点（空指针异常），另一方面 x 作为 null，失去 parent 的引用，双黑节点无法向上平衡调整。\n双黑 null 节点无法平衡问题源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 // 删除节点 public Node delete(int val) { Node node = search(val); // 待删除节点 if (node == null) return null; // 待删除节点不存在 Node y = node, x; // y 替换 node 节点, x 记录可能影响平衡的子树 boolean originalColor = y.red; // y 原始颜色 if (node.left == null) { x = node.right; transplant(node, node.right); // 右孩子替换 node } else if (node.right == null) { x = node.left; transplant(node, node.left); // 左孩子替换 node } else { y = successor(node); originalColor = y.red; x = y.right; if (y.parent == node) { // y 是 node 的直接右孩子 if (x != null) x.parent = y; } // y 是 node 直接右孩子, 不需要处理右侧逻辑 if (y.parent != node) { // y 不是 node 的直接右孩子 // y 右孩子替换 y transplant(y, y.right); y.right = node.right; y.right.parent = y; } transplant(node, y); // y 替换 node y.left = node.left; y.left.parent = y; y.red = node.red; } if (originalColor == BLACK) // y 是黑色, 从下面替换到上面的 node, 需要调整(红色不影响性质) deleteFixup(x); return node; } // 删除后调整 public void deleteFixup(Node x) { while (x != root \u0026amp;\u0026amp; getColor(x) == BLACK) { if (x == x.parent.left) { // x 是左孩子 Node w = x.parent.right; // w 是 x 的兄弟节点 // 情况1：x 的兄弟节点 w 是红色 if (getColor(w) == RED) { setColor(w, BLACK); // 将 w 变成黑色 setColor(x.parent, RED); // 将 x 的父节点变成红色 leftRotate(x.parent); // 对 x 的父节点左旋 w = x.parent.right; // 旋转后，更新兄弟节点 w } // 情况2：x 的兄弟节点 w 是黑色，且 w 的两个子节点都是黑色 if (getColor(w.left) == BLACK \u0026amp;\u0026amp; getColor(w.right) == BLACK) { setColor(w, RED); // 将 w 变成红色 x = x.parent; // 继续从父节点向上修复 } else { // 情况3：w 是黑色，且 w 的右孩子是黑色，左孩子是红色 if (getColor(w.right) == BLACK) { // 上面判断过都为黑色, 只要右孩子是黑色, 左孩子就是红色 setColor(w.left, BLACK); // 将 w 的左孩子变成黑色 setColor(w, RED); // 将 w 变成红色 rightRotate(w); // 对 w 右旋 w = x.parent.right; // 旋转后，更新兄弟节点 w } // 情况4 可能由情况3 转化而来 // 情况4：w 是黑色，且 w 的右孩子是红色 setColor(w, getColor(x.parent)); // 将 w 设为父节点的颜色 setColor(x.parent, BLACK); // 将父节点设为黑色 setColor(w.right, BLACK); // 将 w 的右孩子设为黑色 leftRotate(x.parent); // 对 x 的父节点左旋 x = root; // 修复完成，将 x 设为根节点 } } else { // 如果 x 是右孩子，和左孩子的操作对称，交换左右操作即可 Node w = x.parent.left; // 情况1：x 的兄弟节点 w 是红色 if (getColor(w) == RED) { setColor(w, BLACK); setColor(x.parent, RED); rightRotate(x.parent); w = x.parent.left; } // 情况2：x 的兄弟节点 w 是黑色，且 w 的两个子节点都是黑色 if (getColor(w.left) == BLACK \u0026amp;\u0026amp; getColor(w.right) == BLACK) { setColor(w, RED); x = x.parent; } else { // 情况3：w 是黑色，且 w 的左孩子是黑色，右孩子是红色 if (getColor(w.left) == BLACK) { setColor(w.right, BLACK); setColor(w, RED); leftRotate(w); w = x.parent.left; } // 情况4：w 是黑色，且 w 的左孩子是红色 setColor(w, getColor(x.parent)); setColor(x.parent, BLACK); setColor(w.left, BLACK); rightRotate(x.parent); x = root; } } } setColor(x, BLACK); // 将最终的 x 设为黑色 } 用以下 case 可以测出空指针问题\n1 2 int[] valuesToInsert = {10, 20, 30, 15, 25, 5, 1}; int[] valuesToDelete = {30, 20, 10}; 删除 30 后的树结构： 20(B) 10(R 20 LE) 25(B 20 RI) 5(B 10 LE) 15(B 10 RI) 1(R 5 LE)\n删除 20 时，直接后继是 25，25 替换 20 后，没办法让 25 的右子树 x 替换 25，因为 x 是 null，无法指定 parent，且后续还需要针对 x 进行平衡操作，因此 x 作为双黑节点无法找到父节点和兄弟节点而无法平衡操作\n解决双黑 null 节点平衡问题 相较于有问题的版本，给 deleteFixup 额外添加一个 parent 参数，用来表示 x 的父引用，这样即使在调整双黑 null 节点，也能顺利找到父节点和兄弟节点。\n除此之外，deleteFixup 还需要额外添加 parent 的更新，例如情况 2，x 向 parent 移动，parent 引用也需要更新\n解决双黑 null 节点平衡问题源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 // 删除节点 public Node delete(int val) { Node node = search(val); // 待删除节点 if (node == null) return null; // 待删除节点不存在 Node y = node, x, parent; // y 替换 node 节点, x 记录可能影响平衡的子树, parent 是 node 直接后续节点替换后 x 的父节点 boolean originalColor = y.red; // y 原始颜色 if (node.left == null) { x = node.right; parent = node.parent; transplant(node, node.right); // 右孩子替换 node } else if (node.right == null) { x = node.left; parent = node.parent; transplant(node, node.left); // 左孩子替换 node } else { // 找 node 直接后续节点, 替换 node 为 y(颜色与 node 同色) y = successor(node); originalColor = y.red; x = y.right; // y 会从右子树移除, 受影响平衡的是 y 的右子树 if (y.parent == node) { // y 是 node 的直接右孩子 parent = y; // 此时 x 可能是 null, 但 x 的父节点就是替换 node 的 y } else { // y 不是 node 的直接右孩子, y 右孩子替换 y parent = y.parent; transplant(y, y.right); y.right = node.right; y.right.parent = y; } transplant(node, y); // y 替换 node y.left = node.left; y.left.parent = y; y.red = node.red; } node.left = node.right = node.parent = null; // 清空 node 引用 if (originalColor == BLACK) // y 从右子树移除到 node, 原来的 y 是黑色则需要调整(红色不影响性质) deleteFixup(x, parent); return node; } /** * 删除后, 从 x 向上修复 * * @param x 修复起点, 可能为 null * @param parent x 的父节点 */ public void deleteFixup(Node x, Node parent) { while (x != root \u0026amp;\u0026amp; getColor(x) == BLACK) { if (x == parent.left) { // x 是左孩子 Node w = parent.right; // w 是 x 的兄弟节点 // 情况1：x 的兄弟节点 w 是红色 if (getColor(w) == RED) { setColor(w, BLACK); // 将 w 变成黑色 setColor(parent, RED); // 将 x 的父节点变成红色 leftRotate(parent); // 对 x 的父节点左旋 w = parent.right; // 旋转后，更新兄弟节点 w } // 情况2：x 的兄弟节点 w 是黑色，且 w 的两个子节点都是黑色 if (getColor(w.left) == BLACK \u0026amp;\u0026amp; getColor(w.right) == BLACK) { setColor(w, RED); // 将 w 变成红色 x = parent; // 继续从父节点向上修复 parent = x.parent; // 更新 parent } else { // 情况3：w 是黑色，且 w 的右孩子是黑色，左孩子是红色 if (getColor(w.right) == BLACK) { // 上面判断过都为黑色, 只要右孩子是黑色, 左孩子就是红色 setColor(w.left, BLACK); // 将 w 的左孩子变成黑色 setColor(w, RED); // 将 w 变成红色 rightRotate(w); // 对 w 右旋 w = parent.right; // 旋转后，更新兄弟节点 w } // 情况4 可能由情况3 转化而来 // 情况4：w 是黑色，且 w 的右孩子是红色 setColor(w, getColor(parent)); // 将 w 设为父节点的颜色 setColor(parent, BLACK); // 将父节点设为黑色 setColor(w.right, BLACK); // 将 w 的右孩子设为黑色 leftRotate(parent); // 对 x 的父节点左旋 x = root; // 修复完成，将 x 设为根节点 } } else { // 如果 x 是右孩子，和左孩子的操作对称，交换左右操作即可 Node w = parent.left; // 情况1：x 的兄弟节点 w 是红色 if (getColor(w) == RED) { setColor(w, BLACK); setColor(parent, RED); rightRotate(parent); w = parent.left; } // 情况2：x 的兄弟节点 w 是黑色，且 w 的两个子节点都是黑色 if (getColor(w.left) == BLACK \u0026amp;\u0026amp; getColor(w.right) == BLACK) { setColor(w, RED); x = parent; parent = x.parent; } else { // 情况3：w 是黑色，且 w 的左孩子是黑色，右孩子是红色 if (getColor(w.left) == BLACK) { setColor(w.right, BLACK); setColor(w, RED); leftRotate(w); w = parent.left; } // 情况4：w 是黑色，且 w 的左孩子是红色 setColor(w, getColor(parent)); setColor(parent, BLACK); setColor(w.left, BLACK); rightRotate(parent); x = root; } } } setColor(x, BLACK); // 将最终的 x 设为黑色 } 当然，也可以增加一个哨兵节点 NIL = new Node() ，不让叶子结点为 null，从而可以保存父引用，代码需要将所有的 null 判断全部改成 NIL 引用的判断，但是也增加了插入操作的复杂性。\nJDK TreeMap 实现删除操作 参考 JDK 21 里的 java.util.TreeMap#deleteEntry 删除红黑树节点操作\nTreeMap 删除操作：\n待删除节点 p，如果左右孩子都存在，则找直接后继节点 s，s 值替换 p，然后 p 下移到 s replacement 是 p 的左右非空子节点（左子树优先），p 可能是待删除节点，也可能是值替换后下移的后继节点 s。而后续的操作都是针对 replacement 删除，再调整平衡。该后续操作无论针对删除原节点 p，还是已经值替换到上面 p 的后继节点 s（s 替换 p 后 s 从 p 右子树移除），这一删除都是成立的。 replacement 不空，则代表 replacement 可以直接替换 p。注意，此时 replacement 是 p 的左右孩子其一，且非空，而 p 的另一个孩子必然为空。 解释：如果 p 有两个非空孩子，则其会在一开始就会进入第一个 if，找到后继节点并值替换。然而找到的后继节点 s 左孩子必然是空的（否则会继续向左孩子遍历），只有可能有非空右孩子。而 p 一开始就没有两个非空孩子，则至多只有一个非空孩子，保证 replacement 取到一个非空孩子并进入 if (replacement != null) 块中 论证 p 有且仅有一个孩子 replacement 非空（左右不重要），就可以直接将 replacement 替换 p，且只需要修改 replacement 父引用和 p.parent 子引用，不需要考虑 replacement 的另一个兄弟（null），直接简化了删除操作，变成一个单一链路的替换，而不考虑 p 可能同时被两个孩子替代 下面都是 p 无孩子情况 替换的 p 是根节点，直接将 root 置空（null 替换根节点） p 非父节点，注释中提到用 p 作为幻影替换自身，即什么都不做，先进行删除后的平衡，然后将父节点的子引用调节为 null ，实现 p 被替换的同时，也能平衡红黑树 TreeMap 删除操作源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 // 删除节点 public void delete(int val) { Node p = search(val); // 待删除节点 if (p == null) return; // 待删除节点不存在 if (p.left != null \u0026amp;\u0026amp; p.right != null) { Node s = successor(p); p.val = s.val; p = s; } // p has 2 children // Start fixup at replacement node, if it exists. Node replacement = (p.left != null ? p.left : p.right); if (replacement != null) { // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement if (p.red == BLACK) deleteFixup(replacement); } else if (p.parent == null) { // return if we are the only node. root = null; } else { // No children. Use self as phantom replacement and unlink. if (p.red == BLACK) deleteFixup(p); if (p.parent != null) { if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; } } } // 删除后调整 public void deleteFixup(Node x) { while (x != root \u0026amp;\u0026amp; getColor(x) == BLACK) { if (x == x.parent.left) { // x 是左孩子 Node w = x.parent.right; // w 是 x 的兄弟节点 // 情况1：x 的兄弟节点 w 是红色 if (getColor(w) == RED) { setColor(w, BLACK); // 将 w 变成黑色 setColor(x.parent, RED); // 将 x 的父节点变成红色 leftRotate(x.parent); // 对 x 的父节点左旋 w = x.parent.right; // 旋转后，更新兄弟节点 w } // 情况2：x 的兄弟节点 w 是黑色，且 w 的两个子节点都是黑色 if (getColor(w.left) == BLACK \u0026amp;\u0026amp; getColor(w.right) == BLACK) { setColor(w, RED); // 将 w 变成红色 x = x.parent; // 继续从父节点向上修复 } else { // 情况3：w 是黑色，且 w 的右孩子是黑色，左孩子是红色 if (getColor(w.right) == BLACK) { // 上面判断过都为黑色, 只要右孩子是黑色, 左孩子就是红色 setColor(w.left, BLACK); // 将 w 的左孩子变成黑色 setColor(w, RED); // 将 w 变成红色 rightRotate(w); // 对 w 右旋 w = x.parent.right; // 旋转后，更新兄弟节点 w } // 情况4 可能由情况3 转化而来 // 情况4：w 是黑色，且 w 的右孩子是红色 setColor(w, getColor(x.parent)); // 将 w 设为父节点的颜色 setColor(x.parent, BLACK); // 将父节点设为黑色 setColor(w.right, BLACK); // 将 w 的右孩子设为黑色 leftRotate(x.parent); // 对 x 的父节点左旋 x = root; // 修复完成，将 x 设为根节点 } } else { // 如果 x 是右孩子，和左孩子的操作对称，交换左右操作即可 Node w = x.parent.left; // 情况1：x 的兄弟节点 w 是红色 if (getColor(w) == RED) { setColor(w, BLACK); setColor(x.parent, RED); rightRotate(x.parent); w = x.parent.left; } // 情况2：x 的兄弟节点 w 是黑色，且 w 的两个子节点都是黑色 if (getColor(w.left) == BLACK \u0026amp;\u0026amp; getColor(w.right) == BLACK) { setColor(w, RED); x = x.parent; } else { // 情况3：w 是黑色，且 w 的左孩子是黑色，右孩子是红色 if (getColor(w.left) == BLACK) { setColor(w.right, BLACK); setColor(w, RED); leftRotate(w); w = x.parent.left; } // 情况4：w 是黑色，且 w 的左孩子是红色 setColor(w, getColor(x.parent)); setColor(x.parent, BLACK); setColor(w.left, BLACK); rightRotate(x.parent); x = root; } } } setColor(x, BLACK); // 将最终的 x 设为黑色 } 总结 TreeMap 删除操作精妙之处：\nBST 的删除可能删除原节点 p，也可能删除后继节点 s（p 被 s 替换，s 需要从 p 的右子树删除）。方法开始就处理 p 有两孩的情况，下面的后继 s 值替换后，p 会下移至 s ，p 就变成单孩或无孩 接下来才进行真正的引用替换，只需要进行简单的两节点（p.parent, replacement ）修改引用即可，而不涉及两孩争抢 p 的问题 Reference https://www.bilibili.com/video/BV1Ar4y1Q7Js https://oi-wiki.org/ds/rbtree https://tech.meituan.com/2016/12/02/redblack-tree.html https://jingyuexing.github.io/Ebook/Algorithm/算法导论.pdf 《算法导论》第二版在线版，第 13 章 红黑树 源码实现大部分参照《算法导论》：\nhttps://www.cnblogs.com/skywang12345/p/3245399.html https://www.cnblogs.com/skywang12345/p/3624343.html Java JDK TreeMap - https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/TreeMap.java 非常详细的红黑树删除演示：\nhttps://www.bilibili.com/video/BV16m421u7Tb ","date":"2024-11-19T23:13:12+08:00","image":"https://capriwits.com/post/red-black-tree-source-code-analysis/RedBlackTree-icon_hu1679515567375731304.png","permalink":"https://capriwits.com/post/red-black-tree-source-code-analysis/","title":"红黑树源码解析"},{"content":" Spring i18n 抽象封装实践 Spring 国际化基本使用 抽象国际化功能 定义接口 简单 i18n 消息 复杂 i18n 消息 i18n 工具类 使用 总结 Spring i18n 抽象封装实践 Spring 国际化基本使用 首先 maven 引入 spring-web 的依赖 在 resources 目录下，创建一个放国际化文本的文件夹，例如 /resources/i18n/，然后修改 resources/application.yml 配置文件 1 2 3 4 5 spring: messages: basename: i18n/messages encoding: UTF-8 useCodeAsDefaultMessage: true basename 指定翻译文本的前缀，可以带相对路径，即 i18n 文件夹。 messages 是文本前缀，文本名示例：messages.properties（默认文本，messages_en.properties（英文，messages_zh.properties（简体中文\n文本文件格式 有两种，一种直接 k-v 结构翻译，key = value，翻译时传 key，直接返回 value 的字符串；\n另一种用占位符大括号 {0} {1} {2}…\nmessages_en_US.properties： 1 greeting=Hello, {0}! messages_zh_CN.properties： 1 greeting=你好，{0}！ 使用 MessageSource 获取 i18n 文本 前端传 url 参数 lang，指定语言 当用户访问 /greet?name=John\u0026amp;lang=zh_CN 时，返回的消息将是 你好，John！；当用户访问 /greet?name=John\u0026amp;lang=en_US 时，返回的消息将是 Hello, John!。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import java.util.Locale; @RestController public class GreetingController { private final GreetingService greetingService; public GreetingController(GreetingService greetingService) { this.greetingService = greetingService; } @GetMapping(\u0026#34;/greet\u0026#34;) public String greet(@RequestParam String name, @RequestParam String lang) { Locale locale = new Locale(lang.split(\u0026#34;_\u0026#34;)[0], lang.split(\u0026#34;_\u0026#34;)[1]); return greetingService.getGreeting(name, locale); } } 当然，为了前端方便也可以统一用 HTTP Header，然后后端获取创建 java.util.Locale 对象\n1 @RequestHeader(value = \u0026#34;Accept-Language\u0026#34;, defaultValue = \u0026#34;zh-CN\u0026#34;) String lang 后端使用 org.springframework.context.MessageSource#getMessage(java.lang.String, java.lang.Object[], java.util.Locale) 翻译即可 参数分别为：文本 key；渲染参数数组（按顺序，地区对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.MessageSource; import org.springframework.stereotype.Service; import java.util.Locale; @Service public class GreetingService { @Autowired private MessageSource messageSource; public String getGreeting(String name, Locale locale) { return messageSource.getMessage(\u0026#34;greeting\u0026#34;, new Object[]{name}, locale); } } 抽象国际化功能 以上做法是直接替换掉国际化的内容，如果内容不多，且没有一些嵌套的文本，可以直接替换。\n嵌套文本指的是，key1 对应 value 里面，其中一个占位符的内容也是动态生成，拼接而成的。假如 {1} 也是一个国际化文本，对应另一个 key2 的内容，这中嵌套就需要先翻译 {1}，再渲染 value。\n可以写一个工具类，抽象 i18n 渲染功能。\n定义接口 I18nKey 只有一个方法，获取 key，实现类是一个枚举 I18nMessage 是一条 i18n 信息，除了获取 key，还有获取渲染值列表；类型上界限定为 I18nKey 实现类；getValues() 由于渲染的值对象不止 String，还可能是还是一个 I18nMessage，需要递归地渲染，所以获取列表泛型只限制 Object 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * I18n 配置文件 key */ @FunctionalInterface public interface I18nKey { String getKey(); } /** * I18n 基本信息, 包括配置文件 key 和对应模板顺序的待渲染值 * * @param \u0026lt;K\u0026gt; I18n 配置文件 key 类型 * @see I18nKey */ public interface I18nMessage\u0026lt;K extends I18nKey\u0026gt; { /** * 获取 I18n 配置文件 key * * @return I18n 配置文件 key */ K getKey(); /** * 获取 I18n 配置文件 key 对应模板顺序的待渲染值 * * @return I18n 配置文件 key 对应模板顺序的待渲染值 */ List\u0026lt;Object\u0026gt; getValues(); } 简单 i18n 消息 简单 i18n key，对应简单 i18n message，即简单 k-v 结构，无渲染参数 实现 I18nKey 接口，是一个枚举类 下面是审批示例，设计三类，审批添加、操作和撤销的 i18n key 成员变量只有 String key，需要实现接口方法 getKey 为了实现 key 还原枚举对象，实现 fromKey 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 简单 i18n 配置文件 key 枚举, 直接获取 i18n 字符串, 无渲染 * * @see I18nKey * @see SimpleI18nMessage */ @AllArgsConstructor @Slf4j public enum SimpleI18nKey implements I18nKey { /** * 审批添加操作日志 */ APPROVAL_ADD_TYPENAME(\u0026#34;opLog.approvalAdd.typeName\u0026#34;), APPROVAL_ADD_FIELDS_DESCRIPTION(\u0026#34;opLog.approvalAdd.fields.description\u0026#34;), /** * 操作审核操作日志 */ APPROVAL_REVIEW_TYPENAME(\u0026#34;opLog.approvalReview.typeName\u0026#34;), APPROVAL_REVIEW_FIELDS_UNSOLVED(\u0026#34;opLog.approvalReview.fields.unsolved\u0026#34;), APPROVAL_REVIEW_FIELDS_APPROVED(\u0026#34;opLog.approvalReview.fields.approved\u0026#34;), APPROVAL_REVIEW_FIELDS_REJECTED(\u0026#34;opLog.approvalReview.fields.rejected\u0026#34;), /** * 撤销审批操作日志 */ APPROVAL_WITHDRAW_TYPENAME(\u0026#34;opLog.approvalWithdraw.typeName\u0026#34;), APPROVAL_WITHDRAW_FIELDS_AUTOWITHDRAW(\u0026#34;opLog.approvalWithdraw.fields.autoWithdraw\u0026#34;), ; public final String key; @Override public String getKey() { return key; } /** * 根据给定的字符串查找对应的枚举对象, 主要应用在操作日志从数据库取出后还原 Key 枚举对象 * * @param key i18n 配置文件 key 字符串 * @return 匹配的枚举对象，如果没有找到则返回 {@code null} */ public static SimpleI18nKey fromKey(String key) { for (SimpleI18nKey i18nKey : SimpleI18nKey.values()) { if (i18nKey.getKey().equals(key)) { return i18nKey; } } log.error(\u0026#34;I18n key not found: [{}]\u0026#34;, key); return null; } } 简单 i18n 消息体 成员变量是泛型中同类型的 SimpleI18nKey 枚举对象 实现 I18nMessage 接口方法 获取 key，直接返回成员变量 获取渲染参数列表，简单 kv 消息，无渲染参数，返回 null 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * 简单 i18n 消息体, 无需渲染(无 args), 根据 key 直接获取 i18n 内容 * * @see SimpleI18nKey */ @AllArgsConstructor public class SimpleI18nMessage implements I18nMessage\u0026lt;SimpleI18nKey\u0026gt; { public final SimpleI18nKey key; @Override public SimpleI18nKey getKey() { return key; } /** * 无需渲染(无 args) * * @return {@code null} */ @Override public List\u0026lt;Object\u0026gt; getValues() { return null; } } 复杂 i18n 消息 复杂 i18n 消息，即带有渲染的 i18n 消息，渲染值可能带有 i18n message 需要递归渲染\n以添加操作审批日志为例， I18nKey 实现类同样是一个枚举，只有 String key 一个成员变量；\nI18nMessage 实现类，泛型 ApprovalAddAdditionOtherI18nKey 限制 i18n key 类型，待渲染信息有两个，放在成员变量位置，同 key，由有参构造方法统一设置；可以看到 description 变量对应第二个参数 {1} 同样是一个 I18nMessage，该 i18n message 泛型限制为简单 i18n key；获取渲染参数 getValues() 时，按顺序传入 approvalId 和 description\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * 添加审批操作日志 i18n 配置文件 key * * @see ApprovalAddAdditionOtherI18nMsg */ @AllArgsConstructor public enum ApprovalAddAdditionOtherI18nKey implements I18nKey { ADDITION_OTHER(\u0026#34;opLog.approvalAdd.addition.other\u0026#34;); public final String key; @Override public String getKey() { return key; } } @AllArgsConstructor public class ApprovalAddAdditionOtherI18nMsg implements I18nMessage\u0026lt;ApprovalAddAdditionOtherI18nKey\u0026gt; { // 发起未知类型审批；审批ID = {0}；{1} public final ApprovalAddAdditionOtherI18nKey key; public final Integer approvalId; public final I18nMessage\u0026lt;SimpleI18nKey\u0026gt; description; @Override public ApprovalAddAdditionOtherI18nKey getKey() { return key; } @Override public List\u0026lt;Object\u0026gt; getValues() { return Arrays.asList(approvalId, description); } } i18n 工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 /** * I18n 工具类 \u0026lt;p\u0026gt; * 提供两种方式渲染国际化信息 * \u0026lt;ol\u0026gt; * \u0026lt;li\u0026gt;根据 key 直接渲染国际化消息\u0026lt;/li\u0026gt; {@link #processI18nMessage(String, Locale, Object...)} * \u0026lt;li\u0026gt;根据 {@link I18nMessage} 实现类渲染国际化消息\u0026lt;/li\u0026gt; {@link #processI18nMessage(I18nMessage, Locale)} * \u0026lt;/ol\u0026gt; * * @see I18nMessage * @see I18nKey * @see SimpleI18nMessage */ @Slf4j @Component(\u0026#34;i18n-utils\u0026#34;) public class I18nUtils { private final MessageSource messageSource; @Autowired public I18nUtils(MessageSource messageSource) { this.messageSource = messageSource; } /** * 直接根据 key 获取国际化消息 * * @param key i18n 配置文件 key * @param locale {@link Locale} 语言环境 * @param args 按模板顺序的参数列表, 可为 {@code null} * @return 渲染后国际化消息 */ public String processI18nMessage(String key, Locale locale, Object... args) { // 为避免渲染模版出现多余分隔符, 如 Integer 增加千位逗号分隔符, 统一 String 进行渲染 String[] argsArray = Arrays.stream(args).map(String::valueOf).toArray(String[]::new); return getMessage(key, locale, argsArray); } /** * 直接根据 key 获取国际化消息, 渲染失败时返回默认消息 * * @param key i18n 配置文件 key * @param defaultMessage 默认消息, 可为 {@code null} * @param locale {@link Locale} 语言环境 * @param args 按模板顺序的参数列表, 可为 {@code null} * @return 渲染后国际化消息 */ public String processI18nMessage(String key, @Nullable String defaultMessage, Locale locale, Object... args) { // 为避免渲染模版出现多余分隔符, 如 Integer 增加千位逗号分隔符, 统一 String 进行渲染 String[] argsArray = Arrays.stream(args).map(String::valueOf).toArray(String[]::new); return getMessage(key, locale, defaultMessage, argsArray); } /** * 根据 {@link I18nMessage} 实现类和 {@link Locale} 语言环境获取渲染后的国际化消息 * * @param i18nMessage {@link I18nMessage} 实现类, 国际化消息 * @param locale {@link Locale} 语言环境 * @return 渲染后的国际化消息 */ public String processI18nMessage(@NonNull I18nMessage\u0026lt;?\u0026gt; i18nMessage, @NonNull Locale locale) { return resolveMessage(i18nMessage, locale); } /** * 处理国际化消息 * * @param i18nMessage {@link I18nMessage} 实现类, 国际化消息 * @param locale {@link Locale} 语言环境 * @return 渲染后的国际化消息 */ private String resolveMessage(@NonNull I18nMessage\u0026lt;?\u0026gt; i18nMessage, @NonNull Locale locale) { // 直接渲染简单国际化消息 if (i18nMessage instanceof SimpleI18nMessage) { return getMessage(i18nMessage.getKey().getKey(), locale, null); } String[] args = i18nMessage.getValues().stream() .map(value -\u0026gt; value instanceof I18nMessage ? resolveMessage((I18nMessage\u0026lt;?\u0026gt;) value, locale) : value) .map(String::valueOf) .toArray(String[]::new); return getMessage(i18nMessage.getKey().getKey(), locale, args); } /** * 获取国际化消息 * * @param key i18n 配置文件 key * @param locale {@link Locale} 语言环境 * @param args 按模板顺序的参数列表, 可为 {@code null} * @return 渲染后国际化消息; 若未找到消息, 返回空字符串 */ private String getMessage(String key, Locale locale, String[] args) { String i18nMessage = \u0026#34;\u0026#34;; try { i18nMessage = messageSource.getMessage(key, args, locale); } catch (NoSuchMessageException e) { log.error(\u0026#34;Resolve i18n message [{}] error\u0026#34;, key, e); } return i18nMessage; } /** * 获取国际化消息 * * @param key i18n 配置文件 key * @param locale {@link Locale} 语言环境 * @param defaultMessage 渲染失败, 默认消息 * @param args 按模板顺序的参数列表, 可为 {@code null} * @return 渲染后国际化消息; 若未找到消息, 返回默认消息 */ private String getMessage(String key, Locale locale, String defaultMessage, String[] args) { return messageSource.getMessage(key, args, defaultMessage, locale); } } 渲染的主要类是通过 org.springframework.context.MessageSource 渲染的参数 args 虽然是 Object 数组，不限制类型，但是传入 Integer 时，渲染千位以上的值时，会自动带上千分位分隔符，类似 1,000 ，因此渲染千统一将 args 转为 String ，保持原数值格式 org.springframework.context.MessageSource#getMessage(java.lang.String, java.lang.Object[], java.util.Locale) 找不到 i18n key，默认会抛出 NoSuchMessageException 异常，而不是返回 null，需要注意 org.springframework.context.MessageSource#getMessage(java.lang.String, java.lang.Object[], java.lang.String, java.util.Locale) 提供 defaultMessage 参数，找不到 i18n key 不抛异常，返回默认字符串 processI18nMessage(String key, Locale locale, Object... args) 参数同 getMessage，直接根据字符串 key 获取 i18n 消息，不建议使用，因为实际使用有大量魔法值，即 i18n key 是魔法值字符串，统一用枚举管理便于复用，注释和查看引用。 processI18nMessage(@NonNull I18nMessage\u0026lt;?\u0026gt; i18nMessage, @NonNull Locale locale) 渲染 i18n 信息方法，只需要 i18n message 对象和地区对象 Locale ；I18nMessage 会带有 key 信息，因此只需要一个对象即可 resolveMessage(@NonNull I18nMessage\u0026lt;?\u0026gt; i18nMessage, @NonNull Locale locale) 处理 i18n message 的核心方法，先判断 i18n message 是否为简单 i18n 消息 SimpleI18nMessage，如果是，直接 getMessage；如果不是，需要将参数 args 依次获取，判断 instanceof I18nMessage ，是 i18n message 递归处理消息即可，直到所有国际化消息都被渲染 使用 1 2 3 4 5 6 7 public String getShowAddition(Locale lang) { I18nUtils i18n = BeanContext.getBean(I18nUtils.class); SimpleI18nMessage descMsg = new SimpleI18nMessage(SimpleI18nKey.APPROVAL_ADD_FIELDS_DESCRIPTION); return i18n.processI18nMessage(new ApprovalAddAdditionOtherI18nMsg( ApprovalAddAdditionOtherI18nKey.ADDITION_OTHER, approvalId, descMsg) , lang); } getShowAddition 传入 Locale 地区对象 先用 org.springframework.beans.factory.BeanFactory#getBean(java.lang.Class\u0026lt;T\u0026gt;) 获取 i18n 工具类 创建简单 i18n 消息，指定其 i18n 枚举 key 创建复杂 i18n 消息，先指定复杂 i18n key，然后按渲染顺序传入成员变量，其中 description 是上面创建的简单 i18n 消息 总结 以上递归渲染的抽象工具类，在复杂的递归渲染场景可以比较方便地使用，语义和可读性都较高。\n如只有简单的 i18n 消息渲染场景，直接使用 MessageSource 渲染即可，无需过度封装；注意管理好 i18n key 的魔法值。\n","date":"2024-09-11T15:03:29+08:00","image":"https://capriwits.com/post/spring-i18n-abstract-encapsulation-practice/spring-cover_hu11476348701166988821.png","permalink":"https://capriwits.com/post/spring-i18n-abstract-encapsulation-practice/","title":"Spring i18n 抽象封装实践"},{"content":" MongoDB 修改表分片规则 背景 原理 解决方案 RenameCollection 影子拷贝 mongodump 和 mongorestore mongoexport 和 mongoimport MongoDB 修改表分片规则 背景 Golang 模块需要 upsert MongoDB 的一个 Collection，该表的分片键 Sharding key 规则是指定 pid 和 did 双主键， 业务上需要改为 did 单主键，直接使用 golang mongo-driver 的 FindOneAndUpdate 操作会报错\nshadow fail to Update Mongodb (ShardKeyNotFound) Query for sharded findAndModify must contain the shard key\n原因是分片键的规则与查询的 filter 对不上（did 单主键\n为了适配业务，需要将该表的分片规则进行修改，改为 did 单主键\n测试环境：MongoDB 3.6 版本，分片两份 shard-0 和 shard-1\n以下方案需要停机操作，无法做到读写操作同时修改（需要将原表删除\n原理 参照 MySQL 影子拷贝法\n将待修改表 base 表 copy 一份影子 base_tmp，该影子的分片键规则进行修改，再将 base 表改为 base_bak 用于冗余保留备份，也可 dump 成文件，然后 base_tmp 改为 base 表\n解决方案 RenameCollection 影子拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 use admin; // Step 1: 创建影子拷贝并设置新分片键 db.runCommand({ shardCollection: \u0026#34;db_name.base\u0026#34;, key: {did: 1} }); use db_name; // Step 2: 复制数据 db.base.find().forEach(function (doc) { db.base_tmp.insertOne(doc); }); // Step 3: 重命名原始集合以保留备份 db.base.renameCollection(\u0026#34;base_bak\u0026#34;); // Step 4: 重命名临时集合为原始集合 db.base_tmp.renameCollection(\u0026#34;base\u0026#34;); 实际操作会在 renameCollection 这一步报错\nYou can't rename a sharded collection\n不能修改一个分片的表，因此解决方案只能将数据 dump 出来，再 restore 回新分片的表里\nmongodump 和 mongorestore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // mongodump 备份数据 mongodump --host ip:port --username ROOT --password PASSWORD --authenticationDatabase admin --db DB_NAME --collection base --out=base.bak.d // 删除 base 表 db.base.drop() // 创建分片需要 root 账户，admin 表中 use admin; // 创建影子拷贝并设置新分片键 db.runCommand({ shardCollection: \u0026#34;db_name.base\u0026#34;, key: {did: 1} }); sh.status() // 检查新分片规则 mongorestore --host ip:port --username ROOT --password PASSWORD --authenticationDatabase admin --db DB_NAME --collection base --dir=ota_shadow_device_base.bak.d/DB_NAME/base.bson Failed: ota_car_online.ota_shadow_device_base: error creating indexes for ota_car_online.ota_shadow_device_base: createIndex error: { mongodb-mongodb-sharding-shard-0/mongodb-mongodb-sharding-shard0-data-0.mongodb-mongodb-sharding-headless.bota-basic.svc.cluster.local:27017, mongodb-mongodb-sharding-shard0-data-1.mongodb-mongodb-sharding-headless.bota-basic.svc.cluster.local:27017, mongodb-mongodb-sharding-shard0-data-2.mongodb-mongodb-sharding-headless.bota-basic.svc.cluster.local:27017: \u0026quot;request doesn't allow collection to be created implicitly\u0026quot;, mongodb-mongodb-sharding-shard-1/mongodb-mongodb-sharding-shard1-data-0.mongodb-mongodb-sharding-headless.bota-basic.svc.cluster.local:27017, mongodb-mongodb-sharding-shard1-data-1.mongodb-mongodb-sharding-headless.bota-basic.svc.cluster.local:27017, mongodb-mongodb-sharding-shard1-data-2.mongodb-mongodb-sharding-headless.bota-basic.svc.cluster.local:27017: \u0026quot;cannot create unique index over { pid: 1.0, did: 1.0 } with shard key pattern { did: 1.0 }\u0026quot; }\n使用 mongodump 指定 collection 只导出该 collection 的 bson 信息，但是还会带有额外的原始集合元数据，包括分片信息，因此旧数据的分片规则并不适用新分片集合中，所以 mongorestore 会报错\nmongoexport 和 mongoimport mongoexport 和 mongoimport 的组合，一般涉及到单表，且纯数据操作，不涉及与 MongoDB 属性绑定的场景，例如导出导入 json csv 数据，因此使用该方案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 修改 ota_shadow_device_base 分片规则 # 1. 在 /mongodb/bin 目录下，将 ota_shadow_device_base 数据备份 mongoexport --host IP:PORT --username $ROOT --password $PASSWORD --authenticationDatabase admin --db $DB_NAME --collection ota_shadow_device_base --out ota_shadow_device_base.json --readPreference primary # 2. 删除原集合(务必先执行上述备份 mongo --host IP:PORT --username $ROOT --password $PASSWORD --authenticationDatabase admin --eval \u0026#34;db.ota_shadow_device_base.drop();\u0026#34; ota_car_online # 3. 使用 ROOT 账户进入 mongo-cli # 手动创建集合，建立索引 use ota_car_online; db.createCollection(\u0026#39;ota_shadow_device_base\u0026#39;); db.ota_shadow_device_base.createIndex({did: 1}, {unique: true}); db.ota_shadow_device_base.createIndex({pid: 1}); # 手动创建集合分片规则（需 ROOT 账户才能创建 use admin; db.runCommand({shardCollection: \u0026#39;ota_car_online.ota_shadow_device_base\u0026#39;, key: {did: 1}}); # 以下命令检查分片规则是否生效 # ota_car_online.ota_shadow_device_base, shard key: { \u0026#34;did\u0026#34; : 1 } sh.status(); # 4. 数据还原 # 退出 mongo-cli，在备份文件根目录处恢复数据，按照新分片规则导入数据 mongoimport --host IP:PORT --username $ROOT --password $PASSWORD --authenticationDatabase admin --db $DB_NAME --collection ota_shadow_device_base --file ota_shadow_device_base.json --writeConcern majority sh.status() 查看分片是否设置成功\n","date":"2024-07-12T22:58:46+08:00","image":"https://capriwits.com/post/mongodb-modifying-table-sharding-rules/mongodb-cover_hu17737138940704033801.jpg","permalink":"https://capriwits.com/post/mongodb-modifying-table-sharding-rules/","title":"MongoDB 修改表分片规则"},{"content":" HTTPS 单双向认证及证书相关 一些常识 CA 证书和私钥 服务端和客户端SSL证书 证书格式 证书请求 证书链 HTTPS 单向认证（SSL/TLS) HTTPS 双向认证（mTLS） 自签名证书 mTLS 实战 自签名根证书 CA 自签名服务端证书 自签名客户端证书 验证 带证书的成功调用 不带证书的调用 Reference HTTPS 单双向认证及证书相关 一些常识 CA 证书和私钥 CA（Certificate Authority）证书：由权威认证机构（CA）签发的数字证书，用于证明证书持有者的身份。CA证书可以自签名，也可以由更上级的CA签名。根CA证书通常是自签名的，用 root.key 签名一个 root.crt 根证书。CA 证书可能是一个根证书（root.crt），也可能是一个中间证书（子 CA 证书）。 CA 私钥：用于签发和验证其他证书。CA私钥非常重要，必须妥善保管，确保不会泄露。 公钥是存储在证书里的，key 是私钥，用于签发证书 常见 CA 机构，可以签发服务端 SSL 证书\nLet\u0026rsquo;s Encrypt：Let\u0026rsquo;s Encrypt 是一个免费的、自动化的证书颁发机构，致力于推动全球网站加密化。 DigiCert：DigiCert 是一家知名的商业证书颁发机构，提供各种 SSL/TLS 证书和数字证书解决方案。 Sectigo（原名Comodo）：Sectigo 是一家全球领先的数字证书颁发机构，提供 SSL 证书、代码签名证书等安全解决方案。 GlobalSign：GlobalSign 是一家全球性的数字证书颁发机构，提供 SSL 证书、代码签名证书、身份验证等服务。 GoDaddy：GoDaddy 是一家知名的域名注册商，也提供 SSL 证书和其他网络安全服务。 Entrust Datacard：Entrust Datacard 是一家提供数字证书、身份验证和加密解决方案的领先供应商。 服务端和客户端SSL证书 服务端SSL证书：安装在服务器上的数字证书，用于加密客户端和服务器之间的通信，确保数据的安全性和完整性。通常由 CA 签发，包含服务器的公钥信息。（server.crt 客户端SSL证书：安装在客户端上的数字证书，用于验证客户端的身份，通常在双向认证（mTLS）中使用。(client.crt 证书格式 X.509 X.509 格式证书是一种标准的公钥证书格式，X.509 证书的主要特点和组成部分包括：\n标准化格式：X.509 定义了一个结构化的证书格式，确保了不同系统之间能够互操作和理解。 公钥信息：证书包含了证书持有者的公钥，这是用于加密数据或验证数字签名的关键部分。 身份信息：证书还包括证书持有者的身份信息，如组织名称、组织单元、国家/地区等。这些信息帮助验证证书持有者的身份。 签名：证书由证书颁发机构（CA）进行数字签名，以确保其完整性和真实性。这意味着如果证书被篡改，签名将不再有效。 有效期：每个 X.509 证书都有一个有效的时间范围，由“开始日期”和“结束日期”定义。这确保了证书的时效性和定期更新需求。 证书链和信任：X.509 证书通常是证书链的一部分，其中每个证书都由上一级证书颁发机构签名，最终追溯到一个受信任的根证书。这种结构建立了信任链，使得终端用户可以验证证书的合法性。 扩展性：X.509 证书支持扩展字段，允许添加额外信息，如密钥用途、证书策略等，以满足不同应用场景的需求 .crt 后缀证书，可能是 PEM 编码，也可能是 DER 编码\nPEM (Privacy Enhanced Mail) PEM 是一种广泛使用的编码格式，特别是安全领域的数据，如证书、密钥等。PEM 格式使用 Base64 编码的 ASCII 文本表示，并带有 \u0026quot;-----BEGIN CERTIFICATE-----\u0026quot; 和 \u0026quot;-----END CERTIFICATE-----\u0026quot; 的边界标记。可以以 ASCII 的格式存储 X.509 格式的证书 crt。\n证书可以存储公钥、私钥、证书、证书链、证书请求\n公钥：通常以 “-----BEGIN PUBLIC KEY-----” 和 “-----END PUBLIC KEY-----” 为边界\n私钥：通常以 “-----BEGIN PRIVATE KEY-----” 和 “-----END PRIVATE KEY-----” 为边界，或者对于某些类型的私钥（如RSA私钥），可能是 “-----BEGIN RSA PRIVATE KEY-----” 和 “-----END RSA PRIVATE KEY-----”\n证书：包括服务器证书、中间证书等，通常以 “-----BEGIN CERTIFICATE-----” 和 “-----END CERTIFICATE-----” 为边界\n证书请求（如CSR，Certificate Signing Request）：通常以 “-----BEGIN CERTIFICATE REQUEST-----” 和 “-----END CERTIFICATE REQUEST-----” 为边界。\n1 2 3 4 # 查看 PEM 证书信息 openssl x509 -in certificate.pem -text -noout # PEM 转 DER openssl x509 -in cert.crt -outform der -out cert.der DER (Distinguished Encoding Rules) X.509 证书在二进制形式下通常使用 DER 格式。虽然 DER 本身不是证书格式，但它是 X.509 证书 二进制编码 的基础。存证书，没有私钥\n1 2 3 4 # 查看 DER 证书信息 openssl x509 -in certificate.der -inform der -text -noout # DER 转 PEM openssl x509 -in cert.crt -inform der -outform pem -out cert.pem PFX/PKCS12（Public-Key Cryptography Standards #12） 常用于存储私钥和相关的公钥证书链，以 .pfx 或 .p12 为文件扩展名。这种格式可以转换为 PEM 格式，从而提取出私钥和证书。通常包含私钥、证书和证书链的组合\nPKCS12 可以包含 公钥、私钥、证书和证书链 ，并且有 密码保护 ，一般便于不同平台传输，常用于客户端证书（client.crt → client.p12\n1 2 3 4 # 查看 p12 证书信息 openssl pkcs12 -info -in your_certificate.p12 # p12 转 pem openssl pkcs12 -in your_certificate.p12 -nocerts -out private_key.pem JKS（Java KeyStore） JKS 是 Java 中用于存储密钥和证书的专有格式，二进制格式。JKS 文件通常以 .jks 为文件扩展名。在 Java 应用程序中管理密钥和证书，包括私钥、证书、证书链等信息。JKS 文件通常需要密码来保护存储在其中的密钥和证书。\n生成和转换需要用到 Java keytool\n证书请求 CSR（Certificate Signing Request）是一种包含有关组织或个人信息的加密文本，用于向证书颁发机构（CA）申请数字证书。CSR包含了将包含在数字证书中的 公钥，以及与该公钥相关联的组织信息，如组织名称、域名等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 先创建一个私钥 key openssl genrsa -out root.key 4096 # 再根据 key 生成一个证书请求 openssl req -new -out root.csr -key root.key # 下面是提示出来需要填写到 csr 的信息，包括国家、省、城市、公司、单位、域名、密码等信息 Country Name (2 letter code) [XX]:cn State or Province Name (full name) []:bj Locality Name (eg, city) [Default City]:bj Organization Name (eg, company) [Default Company Ltd]:alibaba Organizational Unit Name (eg, section) []:test Common Name (eg, your name or your servers hostname) []:root Email Address []:a.alibaba.com A challenge password []: An optional company name []: # 用 key 和 csr 生成 10 年期限的根证书 root.crt openssl x509 -req -in root.csr -out root.crt -signkey root.key -CAcreateserial -days 3650 生成的 root.csr 证书请求，一方面包含公司信息，另一方面包含 key 对应的公钥。\n用 key 和 csr 就可以签发一个证书 root.crt。假设公司信息不改变，key 也未泄露，由于公私钥是对应的，理论上等到 root.crt 过期后，可以再次签发一个 root.crt，达到续签的目的。\n证书链 证书链是指从根证书（Root Certificate）开始，通过中间证书（Intermediate Certificate）逐级签发，直到最终的终端用户证书（End-Entity Certificate）\n根证书（Root Certificate）：自签名的证书，位于证书链的最顶端。根证书由权威认证机构（CA）发行并保存在受信任的存储区中。 中间证书（Intermediate Certificate）：由根证书或其他中间证书签发，形成证书链。中间证书用于签发更下级的证书。 终端用户证书（End-Entity Certificate）：由根证书或中间证书签发，最终用于服务器或客户端。 root.crt → intermediate1.crt → intermediate2.crt → server.crt\n以上过程 root.crt 是根证书，以 root.crt 为 CA 签发中间证书 intermediate1.crt，再用 intermediate1.crt 为 CA 签发 intermediate2.crt 中间证书，最后 intermediate2.crt 签发终端用户证书 server.crt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 openssl genrsa -out root.key 4096 # 根私钥 # 根证书 openssl req -new -x509 -days 3650 -key root.key -out root.crt -subj \u0026#34;/CN=Root CA\u0026#34; openssl genrsa -out intermediate1.key 4096 # 中间证书 1 私钥 # 中间证书请求 1 openssl req -new -key intermediate1.key -out intermediate1.csr -subj \u0026#34;/CN=Intermediate CA 1\u0026#34; # 根证书签发中间证书 1 openssl x509 -req -in intermediate1.csr -CA root.crt -CAkey root.key -CAcreateserial -out intermediate1.crt -days 3650 openssl genrsa -out intermediate2.key 4096 # 中间证书 2 私钥 # 中间证书请求 2 openssl req -new -key intermediate2.key -out intermediate2.csr -subj \u0026#34;/CN=Intermediate CA 2\u0026#34; # 中间证书 1 做 CA 签发中间证书 2 openssl x509 -req -in intermediate2.csr -CA intermediate1.crt -CAkey intermediate1.key -CAcreateserial -out intermediate2.crt -days 3650 openssl genrsa -out server.key 4096 # 终端用户证书私钥 # 终端用户证书请求 openssl req -new -key server.key -out server.csr -subj \u0026#34;/CN=server.example.com\u0026#34; # 中间证书 2 做 CA 签发终端用户证书 openssl x509 -req -in server.csr -CA intermediate2.crt -CAkey intermediate2.key -CAcreateserial -out server.crt -days 365 根证书（root.crt）：通常保存在操作系统或浏览器的受信任证书存储中。作为信任链的根，客户端无需直接访问它。\n中间证书一（intermediate1.crt）和中间证书二（intermediate2.crt）：保存在服务器上，用于建立完整的证书链。客户端会通过服务器传递的证书链验证服务器证书的可信度。\n终端用户证书（server.crt）和私钥（server.key）：安装在服务器上，用于加密通信和验证服务器身份。\n完整的证书链文件：服务器需要提供一个包含所有中间证书的文件，以便客户端可以验证证书链。可以将中间证书和终端证书合并成一个文件。\n一般来说，证书链的顺序是：SSL 证书 → 中间证书 → 根证书，依次向上游，一般客户端会默认信任根证书，可以省略\n1 cat server.crt intermediate2.crt intermediate1.crt \u0026gt; fullchain.crt 服务器配置示例（以Nginx为例）：\n1 2 3 4 5 6 7 server { listen 443 ssl; server_name example.com; ssl_certificate /path/to/fullchain.crt; ssl_certificate_key /path/to/server.key; } 客户端验证证书链：\n客户端验证终端用户证书是否由中间证书二签发。 客户端验证中间证书二是否由中间证书一签发。 客户端验证中间证书一是否由根证书签发。 客户端检查根证书是否在受信任的根证书列表中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 验证中间证书一是否由根证书签发 openssl verify -CAfile root.crt intermediate1.crt # intermediate1.crt: OK # 接下来，验证中间证书二是否由中间证书一签发。 # 为了验证中间证书二，先创建一个证书链文件，包含根证书和中间证书一。 cat root.crt intermediate1.crt \u0026gt; chain1.pem openssl verify -CAfile chain1.pem intermediate2.crt # intermediate2.crt: OK # 最后，验证终端用户证书是否由中间证书二签发。 # 创建一个证书链文件，包含根证书和所有中间证书。 cat root.crt intermediate1.crt intermediate2.crt \u0026gt; chain2.pem openssl verify -CAfile chain2.pem server.crt # server.crt: OK # 为了完整验证整个证书链，你可以使用以下命令验证整个证书链文件 fullchain.crt： cat server.crt intermediate2.crt intermediate1.crt \u0026gt; fullchain.crt openssl verify -CAfile root.crt fullchain.crt # fullchain.crt: OK HTTPS 单向认证（SSL/TLS) 客户端发起建立HTTPS连接请求，将SSL协议版本的信息发送给服务器端； 服务器端将本机的公钥证书（server.crt）发送给客户端； 客户端读取公钥证书（server.crt），取出了服务端公钥； 客户端生成一个随机数（密钥 R），用刚才得到的服务器公钥去加密这个随机数形成密文，发送给服务端； 服务端用自己的私钥（server.key）去解密这个密文，得到了密钥 R 服务端和客户端在后续通讯过程中就使用这个密钥 R 进行通信了。 服务端部署时，将 server.crt 和 server.key 上传至服务器即可。如果服务端用云服务 LoadBalancer，则将两个文件上传至 LB 绑定的地方，例如阿里云 CLB 界面有证书管理，AWS 有 ACM（AWS Certificate Manager）专门管理证书等；如果服务端用 K8S Ingress 配置 SSL，则将两个文件 base64 到 secret，再将 secret 配置到 ingress 实现 SSL 单向认证。如果用 Nginx，Apache 等服务器，则找到对应的方式上传证书即可。\nkey 私钥用于解密客户端公钥加密的数据，也可以在服务端生成签名。crt 证书配合客户端已经信任的 CA，验证服务端的身份（crt 带有服务端的信息，包括国家、城市、公司、域名、证书起始和过期时间等；\n一般公网环境，客户端默认在本机都会安装操作系统时，默认信任一些 CA，例如微软系统 IIS 专门管理证书，浏览器自动读取，用户无感；\nHTTPS 双向认证（mTLS） 客户端发起建立 HTTPS 连接请求，将 SSL 协议版本的信息发送给服务端； 服务器端将本机的公钥证书（server.crt）发送给客户端； 客户端读取公钥证书（server.crt），取出了服务端公钥； 客户端将客户端公钥证书（client.crt）发送给服务器端； 服务器端使用根证书（root.crt）解密客户端公钥证书，拿到客户端公钥； 客户端发送自己支持的加密方案给服务器端； 服务器端根据自己和客户端的能力，选择一个双方都能接受的加密方案，使用客户端的公钥加密后发送给客户端； 客户端使用自己的私钥解密加密方案，生成一个随机数 R，使用服务器公钥加密后传给服务器端； 服务端用自己的私钥去解密这个密文，得到了密钥 R 服务端和客户端在后续通讯过程中就使用这个密钥 R 进行通信了。 证书准备：\n服务器端公钥证书：server.crt 服务器端私钥文件：server.key 根证书：root.crt 客户端公钥证书：client.crt 客户端私钥文件：client.key 客户端集成证书（包括公钥和私钥，用于浏览器访问场景）：client.p12 所有证书都可以找 CA 机构签发，如果内网使用，非公众，则可以自建 PKI（Public Key Infrastructure） 系统自签发。\n服务器除了单向认证步骤里，上传 server.crt 和 server.key 两个文件外，还需要额外添加 CA 证书 root.crt（假设 CA 证书就是根证书，不是子 CA 证书，否则需要上传整个证书链），这个 client-CA（root.crt) 证书相当于服务端也是一个客户端，需要提前信任一个签发 client.crt 的 CA 证书，便于客户端发送带客户端公钥的 client.crt 时，验明客户端身份，实现双向认证（即额外增加客户端的身份验证）。\n因此客户端本地除了已经信任签发 server.crt 的 CA 证书，也需要上传 client.crt 和 client.key，就像服务端一样，为了可以安装浏览器，还需要将 client.crt 转为 client.p12 便于安装。\n自签名证书 mTLS 实战 找一台机器有 openssl 的 linux 机器模拟自签名\n自签名根证书 CA （1）创建根证书私钥：\n1 openssl genrsa -out root.key 1024 （2）创建根证书请求文件：\n1 openssl req -new -out root.csr -key root.key 后续参数请自行填写，下面是一个例子：\n注意：CA 证书 Common Name 需要保证唯一性，不要与服务端证书或者客户端证书的 Common Name 相同。\n1 2 3 4 5 6 7 8 9 Country Name (2 letter code) [XX]:cn State or Province Name (full name) []:bj Locality Name (eg, city) [Default City]:bj Organization Name (eg, company) [Default Company Ltd]:alibaba Organizational Unit Name (eg, section) []:test Common Name (eg, your name or your servers hostname) []:root Email Address []:a.alibaba.com A challenge password []: An optional company name []: （3）创建根证书：\n1 openssl x509 -req -in root.csr -out root.crt -signkey root.key -CAcreateserial -days 3650 在创建证书请求文件的时候需要注意三点，下面生成服务器请求文件和客户端请求文件均要注意这三点： 根证书的 Common Name 填写 root 就可以，所有客户端和服务器端的证书这个字段需要填写域名，一定要注意的是，根证书的这个字段和客户端证书、服务器端证书不能一样； 其他所有字段的填写，根证书、服务器端证书、客户端证书需保持一致最后的密码可以直接回车跳过。\n经过上面三个命令行，我们最终可以得到一个签名有效期为 10 年的根证书 root.crt，后面我们可以用这个根证书去颁发服务器证书和客户端证书。\n自签名服务端证书 （1）生成服务器端证书私钥：\n1 openssl genrsa -out server.key 1024 （2） 生成服务器证书请求文件，过程和注意事项参考根证书，本节不详述：\n1 openssl req -new -out server.csr -key server.key （3） 生成服务器端公钥证书\n1 openssl x509 -req -in server.csr -out server.crt -signkey server.key -CA root.crt -CAkey root.key -CAcreateserial -days 3650 经过上面的三个命令，我们得到：\nserver.key：服务器端的密钥文件 server.crt：有效期十年的服务器端公钥证书，使用根证书和服务器端私钥文件一起生成\n自签名客户端证书 （1）生成客户端证书密钥：\n1 2 openssl genrsa -out client.key 1024 openssl genrsa -out client2.key 1024 （2） 生成客户端证书请求文件，过程和注意事项参考根证书，本节不详述：\n1 2 openssl req -new -out client.csr -key client.key openssl req -new -out client2.csr -key client2.key （3） 生客户端证书\n1 2 openssl x509 -req -in client.csr -out client.crt -signkey client.key -CA root.crt -CAkey root.key -CAcreateserial -days 3650 openssl x509 -req -in client2.csr -out client2.crt -signkey client2.key -CA root.crt -CAkey root.key -CAcreateserial -days 3650 （4） 生客户端p12格式证书，需要输入一个密码，选一个好记的，比如123456\n1 2 openssl pkcs12 -export -clcerts -in client.crt -inkey client.key -out client.p12 openssl pkcs12 -export -clcerts -in client2.crt -inkey client2.key -out client2.p12 重复使用上面的命令，我们得到两套客户端证书：\nclient.key / client2.key：客户端的私钥文件 client.crt / client2.key：有效期十年的客户端证书 使用根证书和客户端私钥一起生成 client.p12/client2.p12，这个证书文件包含客户端的公钥和私钥，主要用来给浏览器访问使用\n验证 使用 curl 加上证书路径，可以直接测试 Nginx 的 HTTPS 双向认证是否配置成功。下面我们测试三个用例：\n使用 client.crt / client.key 这一套客户端证书来调用服务器端 使用 client2.crt / client2.key 这一套客户端证书来调用服务器端 不使用证书来调用服务器端 带证书的成功调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #--cert指定客户端公钥证书的路径 #--key指定客户端私钥文件的路径 #-k 使用本参数不校验证书的合法性，因为我们用的是自签名证书 #可以使用-v来观察具体的SSL握手过程 curl --cert ./client.crt --key ./client.key https://integration-fred2.fredhuang.com -k -v * Rebuilt URL to: https://47.93.XX.XX/ * Trying 47.93.XX.XX... * TCP_NODELAY set * Connected to 47.93.XX.XX (47.93.XX.XX) port 443 (#0) * ALPN, offering h2 * ALPN, offering http/1.1 * Cipher selection: ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH * successfully set certificate verify locations: * CAfile: /etc/ssl/cert.pem CApath: none * TLSv1.2 (OUT), TLS handshake, Client hello (1): * TLSv1.2 (IN), TLS handshake, Server hello (2): * TLSv1.2 (IN), TLS handshake, Certificate (11): * TLSv1.2 (IN), TLS handshake, Server key exchange (12): * TLSv1.2 (IN), TLS handshake, Request CERT (13): * TLSv1.2 (IN), TLS handshake, Server finished (14): * TLSv1.2 (OUT), TLS handshake, Certificate (11): * TLSv1.2 (OUT), TLS handshake, Client key exchange (16): * TLSv1.2 (OUT), TLS handshake, CERT verify (15): * TLSv1.2 (OUT), TLS change cipher, Client hello (1): * TLSv1.2 (OUT), TLS handshake, Finished (20): * TLSv1.2 (IN), TLS change cipher, Client hello (1): * TLSv1.2 (IN), TLS handshake, Finished (20): * SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384 * ALPN, server accepted to use http/1.1 * Server certificate: * subject: C=CN; ST=BJ; L=BJ; O=Alibaba; OU=Test; CN=integration-fred2.fredhuang.com; emailAddress=a@alibaba.com * start date: Nov 2 01:01:34 2019 GMT * expire date: Oct 30 01:01:34 2029 GMT * issuer: C=CN; ST=BJ; L=BJ; O=Alibaba; OU=Test; CN=root; emailAddress=a@alibaba.com * SSL certificate verify result: unable to get local issuer certificate (20), continuing anyway. \u0026gt; GET / HTTP/1.1 \u0026gt; host:integration-fred2.fredhuang.com \u0026gt; User-Agent: curl/7.54.0 \u0026gt; Accept: */* \u0026gt; \u0026lt; HTTP/1.1 200 OK \u0026lt; Server: nginx/1.17.5 \u0026lt; Date: Sat, 02 Nov 2019 02:39:43 GMT \u0026lt; Content-Type: text/html \u0026lt; Content-Length: 612 \u0026lt; Last-Modified: Wed, 30 Oct 2019 11:29:45 GMT \u0026lt; Connection: keep-alive \u0026lt; ETag: \u0026#34;5db97429-264\u0026#34; \u0026lt; Accept-Ranges: bytes \u0026lt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; * Connection #0 to host 47.93.XX.XX left intact 使用 client2.crt / client2.key 这一套客户端证书来调用服务器端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 curl --cert ./client2.crt --key ./client2.key https://integration-fred2.fredhuang.com -k \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 不带证书的调用 1 2 3 4 5 6 7 8 9 curl https://integration-fred2.fredhuang.com -k \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;400 No required SSL certificate was sent\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;400 Bad Request\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;center\u0026gt;No required SSL certificate was sent\u0026lt;/center\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;center\u0026gt;nginx/1.17.5\u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 三个用例都符合预期，从第一个测试日志中可以看到，整个通信过程较长，客户端验证服务器端的证书，客户端也将自己的证书上传到服务器端进行验证。使用根证书颁发的两个客户端证书都可以正常发起双向HTTPS认证的调用。没有带客户端证书的调用会被服务器端拒绝服务。\nReference 什么是HTTPS双向认证(Mutual TLS authentication)_API 网关(API Gateway)-阿里云帮助中心\n使用CLB部署HTTPS业务（双向认证）_负载均衡(SLB)-阿里云帮助中心\n","date":"2024-06-09T16:47:46+08:00","image":"https://capriwits.com/post/https-tls-and-mtls-and-certificate-related/mtls-cover_hu7423576249796298622.png","permalink":"https://capriwits.com/post/https-tls-and-mtls-and-certificate-related/","title":"HTTPS 单双向认证及证书相关"},{"content":" Java 左值和右值的思考 前言 问题复现 字节码分析 其他实验 Summary 🔗Reference Java 左值和右值的思考 前言 刷算法题，用到小根堆「PriorityQueue」， 其中一个操作让我困惑了很久\n小根堆存储的是原数组为负值的下标，则小根堆堆顶为最小负数的下标\n本意是循环中，让最小负数取到相反数 k 次，变成一个正数\nwhile (k-- \u0026gt; 0) nums[queue.peek()] = -nums[queue.poll()];\n这一操作让我疑惑了很久，根据赋值表达式的性质，应该是从右计算到左，但是如果按照这个逻辑，就会让 poll() 先进行，后面才 peek() ， 这样下标的计算就出错了, 即 peek() 实际取的下标值已经被 poll() 出堆了\n问题复现 1 2 3 4 5 6 public static void main(String[] args) { int[] nums = {2, 1, 0}; PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(List.of(0, 1, 2)); nums[pq.peek()] = -nums[pq.poll()]; System.out.println(Arrays.toString(nums)); // [-2, 1, 0] } 小根存存储原数组下标，此时堆顶为 0\nnums[pq.peek()] = -nums[pq.poll()] 实际执行运行时状态是先执行 peek()，再执行 poll()，即从左到右，与赋值运算符 = 右值赋值给左值不同\n即 nums[0] = -nums[0] 取反\n字节码分析 使用 javap -c Solution.class 反编译字节码分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 32: invokestatic #15 // InterfaceMethod java/util/List.of:(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/List; 35: invokespecial #21 // Method java/util/PriorityQueue.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:(Ljava/util/Collection;)V 38: astore_2 39: aload_1 40: aload_2 41: invokevirtual #24 // Method java/util/PriorityQueue.peek:()Ljava/lang/Object; 44: checkcast #10 // class java/lang/Integer 47: invokevirtual #28 // Method java/lang/Integer.intValue:()I 50: aload_1 51: aload_2 52: invokevirtual #32 // Method java/util/PriorityQueue.poll:()Ljava/lang/Object; 55: checkcast #10 // class java/lang/Integer 58: invokevirtual #28 // Method java/lang/Integer.intValue:()I 先是堆的初始化，然后先执行 peek() 再执行 poll(), 即从左到右的顺序编译\n其他实验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main(String[] args) { int[] nums = {4, 5, 6}; nums[getIndex()] = -nums[getValue()]; // Should call getIndex first, then getValue System.out.println(Arrays.toString(nums)); // [4, -6, 6] } public static int getIndex() { System.out.println(\u0026#34;getIndex called\u0026#34;); return 1; } public static int getValue() { System.out.println(\u0026#34;getValue called\u0026#34;); return 2; } getIndex called\ngetValue called\n[4, -6, 6]\n1 2 3 18: invokestatic #7 // Method getIndex:()I 21: aload_1 22: invokestatic #13 // Method getValue:()I 同样，编译顺序也是从左至右\nSummary 不能按照赋值表达式 = 从右向左运行的思想思考 nums[queue.peek()] = -nums[queue.poll()]; 最终的赋值的确会按照右向左执行「赋值操作」，完成 置相反数 的操作 但是从最终字节码的执行顺序来看，对于 表达式 的计算，会 从左向右 计算，将前序准备工作「取值」完成后，才进行写操作，赋值。 🔗Reference 1005. K 次取反后最大化的数组和\n","date":"2024-06-02T18:57:02+08:00","image":"https://capriwits.com/post/thoughts-on-java-lvalues-and-rvalues/java-programming-cover_hu940919409602284940.png","permalink":"https://capriwits.com/post/thoughts-on-java-lvalues-and-rvalues/","title":"Java 左值和右值的思考"},{"content":" 关于设计绝对值abs的一些思考 最终实现 🔗Reference 关于设计绝对值abs的一些思考 「取绝对值」对于 Integer 毫无疑问直接判断正负\nMath::abs(int) 1 2 3 public static int abs(int a) { return (a \u0026lt; 0) ? -a : a; } 注意到双精度浮点数 Double 官方使用以下实现\nMath::abs(double) 1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0D) ? 0.0D - a : a; } Java 遵循 IEEE-754 标准，因此实现上存在 +0.0 \u0026amp; -0.0 ，两者除了文本表示不同，在计算过程中也不同。如：1 / +- 0.0 得到的结果是 +Infinity \u0026amp; -Infinity\nabs 计算结果仍然是负数，出现错误，原因既是 +0.0 == -0.0\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Solution { public static void main(String[] args) { double x = -0.0; if (1 / abs(x) \u0026lt; 0) { System.out.println(\u0026#34;abs(x) \u0026lt; 0\u0026#34;); } } public static double abs(double a) { return (a \u0026lt; 0) ? -a : a; } } 尝试解决问题，添加判断条件：if (val \u0026lt; 0 || val == -0.0) 对 -0.0 单独考虑，进行双重判断，这里采用 Double::compare(double, double) 实现\n成功实现\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt; 0 || Double.compare(value, -0.0) == 0) { return -value; } return value; } 再追求极致的优化。查看 Double::compare 实现。\n对于正数进行额外的两次比较, 对于 -0.0 进行额外的 三次 比较, 对于 +0.0 进行额外的 四次 比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static int compare(double d1, double d2) { if (d1 \u0026lt; d2) return -1; // Neither val is NaN, thisVal is smaller if (d1 \u0026gt; d2) return 1; // Neither val is NaN, thisVal is larger // Cannot use doubleToRawLongBits because of possibility of NaNs. long thisBits = Double.doubleToLongBits(d1); long anotherBits = Double.doubleToLongBits(d2); return (thisBits == anotherBits ? 0 : // Values are equal (thisBits \u0026lt; anotherBits ? -1 : // (-0.0, 0.0) or (!NaN, NaN) 1)); // (0.0, -0.0) or (NaN, !NaN) } 而实际上，要想实现只需要 Double::doubleToLongBits 方法，将 Double 转 Long\n1 2 3 4 5 6 7 8 9 private static final long MINUS_ZERO_LONG_BITS = Double.doubleToLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } 不过 Double::doubleToLongBits 也只有微不足道的性能提升，因为它会对 NaN 进行约束，NaN 会赋值为 0x7ff8000000000000L ，如果确保 abs 入参肯定是 double，则只需要取出 Double::doubleToRawLongBits\n1 2 3 4 5 6 public static long doubleToLongBits(double value) { if (!isNaN(value)) { return doubleToRawLongBits(value); } return 0x7ff8000000000000L; } 于是就变成这样实现\n1 2 3 4 5 6 7 8 9 private static final long MINUS_ZERO_LONG_BITS = Double.doubleToRawLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToRawLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } 到 JDK8 就结束了，而 JDK9 开始引入 @HotSpotIntrinsicCandidate 注解，即 HotSpot JVM 内部的 JIT compiler 会移除 JDK 中的实现方法，采用 CPU 指令直接实现，这会比高级语言转汇编转机器语言要快很多，毕竟 CPU 并不会在乎数据类型的问题，只需要重新解释(reinterpreting) 储存在 CPU 寄存器的一组位的问题，以便于与 Java 数据类型一致。\n1 2 @HotSpotIntrinsicCandidate public static native long doubleToRawLongBits(double value); 但这么实现，仍然有条件分支，如果 CPU 分支预测(branch predictor) 失误，性能开销就会增大。接下来考虑减少条件分支。\n利用 0.0 与 +/0.0 作差，都会使正负零转化为正零\n1 2 System.out.println(0.0-(-0.0)); // 0.0 System.out.println(0.0-(+0.0)); // 0.0 对方法进行改写\n1 2 3 4 5 6 7 8 9 public static double abs(double value) { if (value == 0) { return 0.0 - value; } if (value \u0026lt; 0) { return -value; } return value; } 注意到对于普通负数而言，0.0 - value 与 -value 的结果相同，所以合并分支\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt;= 0) { return 0.0 - value; } return value; } AKA\n1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0) ? 0.0 - a : a; } 会发现，JDK Math::abs(double,double) 实现相同（逃\n遵循 IEEE-754 的双精度浮点数二进制表达形式，只需要将二进制在高位符号位改成 0 即可实现转正数(abs) ，需要掩码 0x7fffffffffffffffL == 63位 1 bit\n1 System.out.println(Long.bitCount(0x7fffffffffffffffL)); // 63 最终实现 1 2 3 4 public static double abs(double value) { return Double.longBitsToDouble( Double.doubleToRawLongBits(value) \u0026amp; 0x7fffffffffffffffL); } 📌此版本不存在分支，在某些条件下的吞吐量增加 10%，单分支实现在 Java 标准库存在多年，在随即到来的 JDK 18 中，改进版本已经提交「From: 2021/9/18」\n然而在许多情况下，这些改进并没有太大意义，因为 JIT 编译器会适当使用汇编指令(if available) 会完全替代 Java code，所以这种改动并 不能 使程序显著性提升很多（逃\n🔗Reference One does not simply calculate the absolute value\nOpenJDK Double::compare\nJavaSE 8 doubleToLongBits\n","date":"2021-09-18T17:34:24+08:00","image":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/java-programming-cover_hu940919409602284940.png","permalink":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/","title":"关于设计绝对值 abs() 的一些思考"},{"content":" Java For-loop For-each Iterator 效率分析 System.nanoTime 计时测试 数量级：1,000 数量级：10,000 数量级：100,000 JMH BenchMark 基准测试 基准测试结果分析 三种循环的使用建议 For-each 优势于 While-loop 预防Bug 为什么要“将局部变量的作用域最小化” For-each 优势于 For-loop For-each 无法使用的地方 For-each 拓展使用 总结 Java For-loop For-each Iterator 效率分析 System.nanoTime 计时测试 使用 System.nanoTime() 作差计算耗时 LinkedList::get(int index) 时间复杂度为 $O(n)$，loop 中的操作必须保持一致，因此用 ArrayList 做 Iterator 的集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.util.*; public class Solution { public static final int MAGNITUDE = 10000; // 数量级 public static long testForloop(List\u0026lt;String\u0026gt; list) { long start, end; String str = null; start = System.nanoTime(); for (int i = 0; i \u0026lt; MAGNITUDE; i++) { str = list.get(i); } end = System.nanoTime(); return end - start; } public static long testForeach(List\u0026lt;String\u0026gt; list) { long start, end; String str = null; start = System.nanoTime(); for (String s : list) { str = s; } end = System.nanoTime(); return end - start; } public static long testIterator(List\u0026lt;String\u0026gt; list) { long start, end; String str = null; start = System.nanoTime(); Iterator\u0026lt;String\u0026gt; iterator = list.iterator(); while (iterator.hasNext()) { str = iterator.next(); } end = System.nanoTime(); return end - start; } public static void main(String[] args) { /* initialize */ List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; MAGNITUDE; i++) { arrayList.add(String.valueOf(i)); } System.out.println(\u0026#34;For loop: \u0026#34; + testForloop(arrayList)); System.out.println(\u0026#34;Foreach: \u0026#34; + testForeach(arrayList)); System.out.println(\u0026#34;Iterator: \u0026#34; + testIterator(arrayList)); } } 数量级：1,000 For loop: 99000\nForeach: 321700\nIterator: 194500\n数量级：10,000 For loop: 933200\nForeach: 942500\nIterator: 585800\n数量级：100,000 For loop: 3730800\nForeach: 6669800\nIterator: 5215100\n在小数量级上，For-loop 效率会高一点，For \u0026lt; Iterator \u0026lt; For-each， 这里得出的结论根据时间消耗得出，无法仔细比较效率高低，数量级小时，For-loop 效率高一点，整体来说，三者速度级别差不多。\nJMH BenchMark 基准测试 使用到 JMH 基准测试验证三种循环，数量级为百万 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import org.openjdk.jmh.annotations.*; import org.openjdk.jmh.infra.Blackhole; import org.openjdk.jmh.results.format.ResultFormatType; import org.openjdk.jmh.runner.Runner; import org.openjdk.jmh.runner.options.Options; import org.openjdk.jmh.runner.options.OptionsBuilder; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.concurrent.TimeUnit; @State(Scope.Thread) @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) @Fork(1) @Warmup(iterations = 3) @Measurement(iterations = 5) public class JavaLoopBenchMarkTest { private static final int SIZE = 1_000_000; private String[] array; private List\u0026lt;String\u0026gt; arrayList; @Setup public void setup() { array = new String[SIZE]; arrayList = new ArrayList\u0026lt;\u0026gt;(SIZE); for (int i = 0; i \u0026lt; SIZE; i++) { array[i] = String.valueOf(i); arrayList.add(array[i]); } } @Benchmark public void testForLoop(Blackhole bh) { for (int i = 0; i \u0026lt; SIZE; i++) { bh.consume(array[i]); } } @Benchmark public void testForEachLoop(Blackhole bh) { for (String s : array) { bh.consume(s); } } @Benchmark public void testIterator(Blackhole bh) { Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { bh.consume(iterator.next()); } } public static void main(String[] args) throws Exception { Options opt = new OptionsBuilder() .include(JavaLoopBenchMarkTest.class.getSimpleName()) .forks(1) .resultFormat(ResultFormatType.JSON) .result(\u0026#34;benchmark-results.json\u0026#34;) // 生成 json 报告，JMH Visual Chart 可视化分析 .build(); new Runner(opt).run(); } } 基准测试结果分析 1 2 3 4 Benchmark Mode Cnt Score Error Units JavaLoopBenchMarkTest.testForEachLoop avgt 5 143919.250 ± 8507.941 ns/op JavaLoopBenchMarkTest.testForLoop avgt 5 139981.040 ± 4770.272 ns/op JavaLoopBenchMarkTest.testIterator avgt 5 142754.313 ± 8949.872 ns/op 严格来讲三者速度几乎不相上下，硬是要说最快，应该是原生 For-loop, For-each 和 Iterator 应该是一样的\n三种循环的使用建议 《Effective Java》 第三版第 58 条中建议，一般采用 Foreach 进行循环，因为它在 简洁性和 预防Bug上优于 For-loop 和 Iterator（确切说是 Iterator 配合 while 使用）\nFor-each 优势于 While-loop 预防Bug 说到预防Bug，这里牵涉到 第57条 中的 将局部变量的作用域最小化。 为什么要“将局部变量的作用域最小化” 书中提到，原因类似于第 15 条的本质，使类和成员的可访问性最小化。\n将局部变量作用域最小化，可以增强代码的可读性和可维护性，并降低出错的可能性。\n循环中提供了特殊的机会来将变量的作用域最小化。\n无论是传统的 for 循环，还是 for-each 形式的 for 循环，都允许声明循环变量，它们的作用域被限定在正好需要的范围之内。\n如果在循环终止之后不再需要循环变量的内容，for-loop 就优先于 while-loop。\n如下是一种遍历集合的首选做法： 1 2 3 4 // Preferred idiom for iterating over a collection or array for (Element e : c) { ... // Do Someting with e } 如果需要访问迭代器，可能要调用它的 remove 方法，首选做法是利用传统的 for 循环替代 for-each 循环： 1 2 3 4 5 // Idiom for iterating when you need the iterator for (Iterator\u0026lt;Element\u0026gt; i = c.iterator(); i.hasNext(); ) { Element e = i.next(); ... // Do someting with e and i } 为什么有些时候不能用 for-each ，鉴于它是基于 Iterator 的 hasNext() + next()，有时候需要在循环过程中对集合进行操作，\n此时就必须使用 Iterator 对象进行操作了，因为使用 Iterator 循环时，集合的操作权就交给 Iterator，\n虽然可以用集合对象进行操作，如 romove() 但这样会破坏 iterator 初始化的结果，导致最终程序运行的结果与预期偏差很大\n至于为什么 for loop 要比 while loop 更好，参考一下代码片段，连续的两个 while loop，以及出现的一个 bug 1 2 3 4 5 6 7 8 9 Iterator\u0026lt;Element\u0026gt; i = c.iterator(); while (i.hasNext()) { doSometing(i.next()); } ... Iterator\u0026lt;Element\u0026gt; i2 = c.iterator(); while (i.hasNext()) { // This is bug! doSometing(i2.next()); } 在第二个 while loop 中，使用了 迭代器 i 的判断，实际操作的是 i2 迭代器对象, i 迭代器发生泄露，而不会轻易被发现，IDE 也不会报错, 所以要利用好 for loop 声明迭代器，控制它的作用范围\n上面 bug 程序最终的结果是下面的 while loop 不会执行，因为在上面的 while loop 执行结束之后，迭代器 i 就会遍历到尽头，继续判断 i.hasNext() 只会返回 false\nFor-each 优势于 For-loop 以下面一个 两层集合嵌套迭代出现的 bug 来展开讨论 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Can you spot the bug? enum Suit {CLUB, DIAMOND, HEART, SPADE} enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING } ... static Collection\u0026lt;Suit\u0026gt; suits = Arrays.asList(Suit.values()); static Collection\u0026lt;Rank\u0026gt; ranks = Arrays.asList(Rank.values()); List\u0026lt;Card\u0026gt; deck = new ArrayList\u0026lt;\u0026gt;(); for (Iterator\u0026lt;Suit\u0026gt; i = suits.iterator(); i.hasNext(); ) for (Iterator\u0026lt;Rank\u0026gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(i.next(), j.next())); bug在于，在迭代器上对外部的集合 suits 调用太多 next 方法，它应该从外部的循环进行调用，以便每种花色都调用一次，但它却是从内部循环调用，因此每次牌调用一次。在用完所有花色之后，循环就会抛出 NoSuchElementException异常。\n如果碰巧外部集合的大小是内部集合大小的几倍（可能因为它们是相同的集合），循环就会正常终止，但是实际完成情况跟预期是有出入的。\n下面是打印一对骰子出现的所有可能情况： 1 2 3 4 5 6 7 // Same bug, different symptom! enum Face {ONE, TWO, THREE, FOUR, FIVE, SIX} Collection\u0026lt;Face\u0026gt; faces = EnumSet.allOf(Face.class); for (Iterator\u0026lt;Face\u0026gt; i = faces.iterator(); i.hasNext(); ) for (Iterator\u0026lt;Face\u0026gt; j = faces.iterator(); i.hasNext(); ) System.out.println(i.next() + \u0026#34; \u0026#34; + j.next()); ONE ONE\nTWO TWO\nTHREE THREE\nFOUR FOUR\nFIVE FIVE\nSIX SIX\n同样的错误，也是重复调用 next。这种程序不会抛出异常，所以往往找 bug 会特别难受\n下面开始修正此 bug 1 2 3 4 5 6 // Fixed, but ugly - so we need for-each for (Iterator\u0026lt;Suit\u0026gt; i = suits.iterator(); i.hasNext(); ) { Suit suit = i.next(); for (Iterator\u0026lt;Rank\u0026gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(suit, j.next())); } 至此引出 for-each ，让这个问题完全消失，并且产生的代码也能很简洁。 1 2 3 4 // Preferred idiom for neat iteration on collections and arrays for (Suit suit : suits) for (Rank rank : ranks) deck.add(new Card(suit, rank)); For-each 无法使用的地方 解构过滤：如果需要遍历集合，并删除指定元素，需要使用显式的迭代器，以便使用它的 remove 方法。使用 Java 8 中添加的 Collection 的 removeIf，常常可以避免显式遍历。 转换：如果需要遍历列表或者数组，并取代它的部分或者全部元素值，就需要列表迭代器或者数组索引，以便设置元素的值。 平行迭代：如果需要并行地遍历多个集合，就需要显式地控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以同步前进（就如上述有问题的牌和骰子的示例中无意间所示范的那样） For-each 拓展使用 for-each 不止能遍历集合和数组，还能遍历实现 Iterable 接口的任何对象，只需要实现接口对应的方法即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface Iterable\u0026lt;T\u0026gt; { /** * Returns an iterator over elements of type {@code T}. * * @return an Iterator. */ Iterator\u0026lt;T\u0026gt; iterator(); default void forEach(Consumer\u0026lt;? super T\u0026gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } } 比如写一个自定义的 LinkedList 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import java.util.Iterator; import java.util.NoSuchElementException; public class SimpleList\u0026lt;T\u0026gt; implements Iterable\u0026lt;T\u0026gt; { private Node\u0026lt;T\u0026gt; head; private static class Node\u0026lt;T\u0026gt; { T data; Node\u0026lt;T\u0026gt; next; Node(T data) { this.data = data; this.next = null; } } public void add(T data) { if (head == null) { head = new Node\u0026lt;\u0026gt;(data); } else { Node\u0026lt;T\u0026gt; current = head; while (current.next != null) { current = current.next; } current.next = new Node\u0026lt;\u0026gt;(data); } } @Override public Iterator\u0026lt;T\u0026gt; iterator() { return new Iterator\u0026lt;T\u0026gt;() { private Node\u0026lt;T\u0026gt; current = head; @Override public boolean hasNext() { return current != null; } @Override public T next() { if (!hasNext()) { throw new NoSuchElementException(); } T data = current.data; current = current.next; return data; } }; } public static void main(String[] args) { SimpleList\u0026lt;String\u0026gt; list = new SimpleList\u0026lt;\u0026gt;(); list.add(\u0026#34;Hello\u0026#34;); list.add(\u0026#34;World\u0026#34;); list.add(\u0026#34;!\u0026#34;); for (String s : list) { System.out.println(s); } } } 总结 总而言之，与传统的 for 循环相比，for-each 循环在简洁性、灵活性以及出错预防性方面都占有绝对优势，并且没有性能惩罚的问题。\n因此，当可以选择的时候，for-each 循环应该优先于 for 循环。\n","date":"2021-03-16T10:37:29+08:00","image":"https://capriwits.com/post/java-for_loop_for_each_iterator-efficiency-analysis/java-programming-cover_hu940919409602284940.png","permalink":"https://capriwits.com/post/java-for_loop_for_each_iterator-efficiency-analysis/","title":"Java For-loop For-each Iterator 效率分析"},{"content":" Iterator remove 时出现 ConcurrentModificationException 前言 分析 建议用法 Iterator remove 时出现 ConcurrentModificationException 前言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;String\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;b\u0026#34;.equals(cur)) { arrayList.remove(cur); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } /*for (String s : arrayList) { if (\u0026#34;b\u0026#34;.equals(s)) { arrayList.remove(s); } else { System.out.println(s + \u0026#34; \u0026#34;); } }*/ System.out.println(arrayList); } } for-each 实际就是隐式使用 iterator 遍历集合，上面的例子会抛出异常，并删除失败。 a\nException in thread \u0026ldquo;main\u0026rdquo; java.util.ConcurrentModificationException\nat java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:937)\nat java.base/java.util.ArrayList$Itr.next(ArrayList.java:891)\nat Solution.main(Solution.java:14)\n然而删除 倒数第二个 元素却不会报错 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;c\u0026#34;.equals(cur)) { arrayList.remove(cur); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } /*for (String s : arrayList) { if (\u0026#34;c\u0026#34;.equals(s)) { arrayList.remove(s); } else { System.out.println(s + \u0026#34; \u0026#34;); } }*/ System.out.println(arrayList); } } a\nb\n[a, b, d]\n分析 首先先观察 ArrayList 的 iterator()，看迭代器怎么构造。 ArrayList 的 父类 AbstractList 中 1 2 3 public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } Itr 是里面的内部类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 private class Itr implements Iterator\u0026lt;E\u0026gt; { /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() { return cursor != size(); } public E next() { checkForComodification(); try { int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public void remove() { if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet \u0026lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } cursor：下一个要访问的元素的索引 lastRet：上一个访问的元素的索引 expectedModCount 是期望的该 List 被修改的次数，初始化为 modCount modCount 是 AbstractList 的一个成员变量。 The number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.\nThis field is used by the iterator and list iterator implementation returned by the iterator and listIterator methods. If the value of this field changes unexpectedly, the iterator (or list iterator) will throw a ConcurrentModificationException in response to the next, remove, previous, set or add operations. This provides fail-fast behavior, rather than non-deterministic behavior in the face of concurrent modification during iteration.\nUse of this field by subclasses is optional. If a subclass wishes to provide fail-fast iterators (and list iterators), then it merely has to increment this field in its add(int, E) and remove(int) methods (and any other methods that it overrides that result in structural modifications to the list). A single call to add(int, E) or remove(int) must add no more than one to this field, or the iterators (and list iterators) will throw bogus ConcurrentModificationExceptions. If an implementation does not wish to provide fail-fast iterators, this field may be ignored.\n1 protected transient int modCount = 0; 结构修改是指那些改变列表大小的修改，或者以某种方式扰乱列表，使得正在进行的迭代可能产生不正确的结果。 此字段由迭代器和 listIterator方法返回的迭代器和列表迭代器实现使用。如果此字段的值意外更改，迭代器（或列表迭代器）将抛出 ConcurrentModificationException以响应 next、remove、previous、set 或 add 操作。这提供了 快速失败 的行为。 深入 ArrayList 里观察 next() 1 2 3 4 5 6 7 8 9 10 11 public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } 1 2 3 4 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 抛出的 ConcurrentModificationException 异常是 checkForComodification() 抛出的。 条件是：modCount != expectedModCount 所以在 add remove 的过程中 modCount 会自增自减。如果用集合的 remove则 List 的 modCount减少一，而 Iterator 的 expectedModCount不变，就会抛出异常。\n至于为什么倒数第二个元素删除不会报错，我们要先了解 Iterator 遍历的特点。\nwhile + iterator 的组合是需要先判空 hasNext()，然后再 next()，最后才 remove()，否则会报错，可以自行实验，调换 next 和 remove。\n因为要先 next，将游标 越过 当前的元素，然后再决定要怎么操作当前的（游标前面的）这个元素，即游标是插在 当前元素 和 下一个元素 的中间（可以这么理解）。\n删除倒数第二个元素的时候，cursor 指向 最后一个元素，而此时删掉了倒数第二个元素后，cursor 和 size() 正好相等了，所以 hasNext() 返回 false，遍历结束，成功的删除了倒数第二个元素。\n建议用法 一个原则是，尽量在遍历的过程中不要对原集合进行增删，容易改变原结构，可以用 immutable 的思想，重新封装一个集合。\n要 remove() ，则要在 iterator() 上面来进行 remove()，因为 Iterator 迭代，就把操作权交给了 Iterator，就不要再用原集合进行操作了。\n正确用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;a\u0026#34;.equals(cur)) { iterator.remove(); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } System.out.println(arrayList); } } b\nc\nd\n[b, c, d]\n以上分析是基于 ArrayList，基于链表的 LinkedList 道理大同小异，思想不变，测试的结果也是不变的。\n","date":"2021-03-15T20:10:31+08:00","image":"https://capriwits.com/post/iterator-concurrentmodificationexception-problem-when-remove/java-programming-cover_hu940919409602284940.png","permalink":"https://capriwits.com/post/iterator-concurrentmodificationexception-problem-when-remove/","title":"Iterator remove 时出现 ConcurrentModificationException"}]